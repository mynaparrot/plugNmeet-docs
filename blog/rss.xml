<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>  Blog</title>
        <link>https://www.plugnmeet.org/blog</link>
        <description>  Blog</description>
        <lastBuildDate>Mon, 27 Oct 2025 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture]]></title>
            <link>https://www.plugnmeet.org/blog/backend-architecture-deep-dive</link>
            <guid>https://www.plugnmeet.org/blog/backend-architecture-deep-dive</guid>
            <pubDate>Mon, 27 Oct 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.]]></description>
            <content:encoded><![CDATA[<p>Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.</p>
<p>When we designed plugNmeet, we had a clear set of goals: the platform needed to be high-performance, horizontally scalable, resilient, and easy for developers to build upon. This led us to make two fundamental decisions for our backend: we chose <strong>LiveKit</strong> for our media server and <strong>NATS</strong> for our real-time messaging layer.</p>
<p>This article is a deep dive into the "why" behind these critical choices.</p>
<hr>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="the-two-pillars-of-real-time-communication">The Two Pillars of Real-Time Communication<a href="https://www.plugnmeet.org/blog/backend-architecture-deep-dive#the-two-pillars-of-real-time-communication" class="hash-link" aria-label="Direct link to The Two Pillars of Real-Time Communication" title="Direct link to The Two Pillars of Real-Time Communication" translate="no">​</a></h2>
<p>At its core, any serious video conferencing platform has to solve two distinct problems. But for a project like plugNmeet, it's not enough to just make them work. The solution must also be:</p>
<ul>
<li class=""><strong>Easy to Scale:</strong> Able to grow from handling a few dozen users to many thousands without a complete re-architecture.</li>
<li class=""><strong>Highly Available:</strong> Resilient to failure, ensuring that the loss of a single component doesn't bring the entire system down.</li>
<li class=""><strong>Resource-Efficient &amp; Cost-Effective:</strong> Designed to run on reasonable hardware, keeping operational costs low for everyone.</li>
<li class=""><strong>Easy to Manage:</strong> Simple to deploy and maintain, even for small teams or individual developers.</li>
</ul>
<p>Our architectural philosophy was to choose a best-in-class open-source tool for each of the two main challenges—<strong>Media Routing</strong> and <strong>Signaling</strong>—that met all of these demanding criteria.</p>
<ol>
<li class=""><strong>Media Routing:</strong> How do you efficiently get audio and video streams from each participant to every other participant?</li>
<li class=""><strong>Signaling &amp; State Management:</strong> How do you instantly deliver all the other real-time information that makes a meeting dynamic and interactive?</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="pillar-1-livekit---the-high-performance-media-engine">Pillar 1: LiveKit - The High-Performance Media Engine<a href="https://www.plugnmeet.org/blog/backend-architecture-deep-dive#pillar-1-livekit---the-high-performance-media-engine" class="hash-link" aria-label="Direct link to Pillar 1: LiveKit - The High-Performance Media Engine" title="Direct link to Pillar 1: LiveKit - The High-Performance Media Engine" translate="no">​</a></h2>
<p>In the early days of WebRTC, many apps used a peer-to-peer (P2P) mesh. This works for a 1-on-1 call, but it fails catastrophically as you add more people. Each participant has to upload their video stream separately to every other person, quickly overwhelming their internet connection.</p>
<p>The modern solution is a <strong>Selective Forwarding Unit (SFU)</strong>. An SFU is a server that acts as a traffic cop. Each participant sends their video stream to the SFU just <em>once</em>, and the SFU then forwards that stream to all other participants.</p>
<p>For our SFU, we chose <strong>LiveKit</strong>, and here’s why:</p>
<ul>
<li class=""><strong>High Performance &amp; Efficiency:</strong> LiveKit is written in Go, making it incredibly fast and resource-efficient. It can handle a large number of concurrent users and streams on a single server, which aligns with our goal of providing a cost-effective solution.</li>
<li class=""><strong>Built-in Scalability:</strong> LiveKit is designed to be clustered, and it uses Redis to manage state across multiple nodes. This provides a clear, documented path to the massive scale required by our largest users.</li>
<li class=""><strong>Modern Features by Default:</strong> LiveKit comes with critical, out-of-the-box support for modern WebRTC features like <strong>Simulcast</strong> (sending multiple quality streams) and <strong>Dynacast</strong> (intelligently pausing streams). This allows plugNmeet to automatically adapt to each user's network conditions, dramatically improving reliability.</li>
<li class=""><strong>Secure and Open Source:</strong> As an open-source project itself, LiveKit aligns with our core philosophy of transparency. It also has built-in support for passing through End-to-End Encrypted (E2EE) media, which is essential for our security model.</li>
</ul>
<p>In short, by building on top of LiveKit, we didn't have to reinvent the wheel. We inherited a powerful, battle-tested media engine, allowing us to focus on building the application logic and features that make plugNmeet unique.</p>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="pillar-2-nats-jetstream---the-resilient-nervous-system">Pillar 2: NATS JetStream - The Resilient Nervous System<a href="https://www.plugnmeet.org/blog/backend-architecture-deep-dive#pillar-2-nats-jetstream---the-resilient-nervous-system" class="hash-link" aria-label="Direct link to Pillar 2: NATS JetStream - The Resilient Nervous System" title="Direct link to Pillar 2: NATS JetStream - The Resilient Nervous System" translate="no">​</a></h2>
<p>While LiveKit handles the heavy media streams, we needed a separate, highly reliable system for all the other real-time data that makes a meeting interactive. This is where <strong>NATS</strong> comes in.</p>
<p>More specifically, we leverage <strong>NATS JetStream</strong>, the powerful persistence layer built into the NATS ecosystem. JetStream elevates NATS from a simple messaging system to a true streaming platform, which is critical for the reliability and scalability of our backend services.</p>
<p>Here’s why JetStream was the perfect choice for plugNmeet:</p>
<ul>
<li class="">
<p><strong>Multi-Layered Security:</strong> NATS provides a robust, defense-in-depth security model at the messaging layer, which operates in addition to our application-level E2EE.</p>
<ul>
<li class=""><strong>Encryption in Transit:</strong> All connections from clients to the NATS cluster are secured using <strong>TLS</strong>. This encrypts all signaling data while it's on the wire, protecting it from eavesdropping.</li>
<li class=""><strong>Fine-Grained Authorization:</strong> This is where the real power lies. When a user authenticates, the <code>plugnmeet-server</code> dynamically generates a unique set of permissions for that specific user session. These permissions strictly define which NATS subjects the user is allowed to publish to and subscribe from, typically scoped by <code>roomId</code> and <code>userId</code>. This enforces a true <strong>principle of least privilege</strong>, making it architecturally impossible for a user in one room to access data from another.</li>
</ul>
</li>
<li class="">
<p><strong>Scalable Request Processing with Queue Workers:</strong> For critical client-server interactions, like fetching the initial user list, we leverage JetStream's powerful <strong>queue worker pattern</strong>. When a client sends a request, it's published to a stream. Our backend <code>plugnmeet-server</code> instances subscribe to this stream as a <strong>queue group</strong>, and NATS ensures that each request is delivered to only <strong>one</strong> available server. This provides automatic, built-in load balancing for our core application logic.</p>
</li>
<li class="">
<p><strong>High-Performance Streaming for Real-Time Data:</strong> For other real-time data like <strong>chat messages</strong> or <strong>collaborative whiteboard</strong> drawing data, we use JetStream's high-performance streaming capabilities to ensure fast and reliable delivery to all participants in a room.</p>
</li>
<li class="">
<p><strong>Built for Resilience:</strong> NATS is designed from the ground up for clustering and self-healing. If one NATS node fails, clients will automatically reconnect to another, ensuring the "nervous system" of your meetings stays online.</p>
</li>
</ul>
<p>By using NATS for its deep security model, performance, and resilience, we built a backend that is fast, secure, and remarkably easy to scale.</p>
<hr>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="conclusion-a-foundation-built-for-the-future">Conclusion: A Foundation Built for the Future<a href="https://www.plugnmeet.org/blog/backend-architecture-deep-dive#conclusion-a-foundation-built-for-the-future" class="hash-link" aria-label="Direct link to Conclusion: A Foundation Built for the Future" title="Direct link to Conclusion: A Foundation Built for the Future" translate="no">​</a></h2>
<p>The choice of LiveKit and NATS JetStream was deliberate. By combining a best-in-class media server with a best-in-class streaming platform, we've created a platform that is:</p>
<ul>
<li class=""><strong>Performant:</strong> Handling both media and signaling with specialized, high-speed tools.</li>
<li class=""><strong>Scalable:</strong> With clear, documented paths for clustering each component.</li>
<li class=""><strong>Resilient:</strong> With built-in failover and self-healing capabilities.</li>
<li class=""><strong>Flexible:</strong> Allowing us to build powerful, decoupled features like our auto-scaling recorders.</li>
</ul>
<p>But there's one more crucial element that ties this all together: <strong>the underlying technology</strong>. Both LiveKit and NATS are written in <strong>Go</strong>, one of the most powerful languages for modern, concurrent network services. This was no accident. We deliberately chose to write the core <code>plugnmeet-server</code> in Go as well.</p>
<p>This creates a <strong>unified, high-performance ecosystem</strong>. Our developers can move seamlessly between components, leading to faster development cycles, easier maintenance, and a more cohesive and stable platform for our users. It means that when you build with plugNmeet, you're building on a consistent and coherent technology stack from top to bottom.</p>
<p>The ultimate benefit of this Go-based approach is in the final deployment. The entire <code>plugnmeet-server</code> compiles down to a <strong>single, dependency-free binary file</strong>. This makes deployment incredibly simple and portable. You can run it as a standalone service on a bare-metal server or package it into a minimal, highly secure Docker container. There are no language runtimes to manage and no complex dependencies to install—just a single file that works.</p>
<p>When you choose plugNmeet, you're not just getting an application. You're getting a thoughtfully designed architecture built on a foundation you can trust.</p>
<hr>
<p><strong>Want to learn more?</strong></p>
<ul>
<li class=""><strong>Read our <a class="" href="https://www.plugnmeet.org/docs/developer-guide/scalable-setup">Scalable Deployment Guide</a></strong></li>
<li class=""><strong>Explore the <a href="https://github.com/mynaparrot/plugNmeet-server" target="_blank" rel="noopener noreferrer" class="">Open-Source Project on GitHub</a></strong></li>
</ul>]]></content:encoded>
            <category>webrtc</category>
            <category>architecture</category>
            <category>backend</category>
            <category>livekit</category>
            <category>nats</category>
            <category>open-source</category>
            <category>scalability</category>
        </item>
        <item>
            <title><![CDATA[How to Build Your Own Video Conferencing App in Under an Hour]]></title>
            <link>https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour</link>
            <guid>https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour</guid>
            <pubDate>Sun, 26 Oct 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[Building a video conferencing application sounds like a monumental task. You have to wrestle with the complexities of WebRTC, set up signaling servers, manage STUN/TURN for NAT traversal, and handle the resource-intensive job of routing media streams. The backend infrastructure alone can take months to build and stabilize.]]></description>
            <content:encoded><![CDATA[<p>Building a video conferencing application sounds like a monumental task. You have to wrestle with the complexities of WebRTC, set up signaling servers, manage STUN/TURN for NAT traversal, and handle the resource-intensive job of routing media streams. The backend infrastructure alone can take months to build and stabilize.</p>
<p>But what if you could skip all of that?</p>
<p>What if you could leverage a powerful, open-source platform that handles all the backend complexity, allowing you to build a fully functional, custom-branded video conferencing app in under an hour? With <strong>plugNmeet</strong>, you can.</p>
<p>This guide will show you the three core steps to building your own video app using plugNmeet's API-first architecture.</p>
<hr>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="the-old-way-the-mountain-of-complexity">The Old Way: The Mountain of Complexity<a href="https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour#the-old-way-the-mountain-of-complexity" class="hash-link" aria-label="Direct link to The Old Way: The Mountain of Complexity" title="Direct link to The Old Way: The Mountain of Complexity" translate="no">​</a></h2>
<p>Before we show you the easy way, it's important to appreciate the problems plugNmeet solves. Building a WebRTC app from scratch requires you to become an expert in:</p>
<ol>
<li class=""><strong>Signaling:</strong> Creating a system (usually with WebSockets) to coordinate connections between users.</li>
<li class=""><strong>NAT Traversal:</strong> Setting up and managing STUN/TURN servers to allow users behind firewalls to connect to each other.</li>
<li class=""><strong>Media Server (SFU):</strong> Deploying and scaling a Selective Forwarding Unit (like LiveKit, Mediasoup, or Janus) to efficiently route video and audio streams.</li>
<li class=""><strong>Backend Logic:</strong> Writing an application server to manage rooms, users, and permissions.</li>
<li class=""><strong>Frontend UI:</strong> Building a complete user interface from scratch to handle video elements, buttons, chat, and more.</li>
</ol>
<p>This is a massive undertaking.</p>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="the-plugnmeet-way-an-api-first-framework">The plugNmeet Way: An API-First Framework<a href="https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour#the-plugnmeet-way-an-api-first-framework" class="hash-link" aria-label="Direct link to The plugNmeet Way: An API-First Framework" title="Direct link to The plugNmeet Way: An API-First Framework" translate="no">​</a></h2>
<p>plugNmeet bundles all of this complexity into a single, open-source server that you can install with an automated script. It provides you with a simple, powerful set of APIs that act as your building blocks.</p>
<p>Here's how you build your app in three steps.</p>
<h3 class="anchor anchorTargetStickyNavbar_f97l" id="step-1-set-up-the-backend-5-minutes">Step 1: Set Up the Backend (5 Minutes)<a href="https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour#step-1-set-up-the-backend-5-minutes" class="hash-link" aria-label="Direct link to Step 1: Set Up the Backend (5 Minutes)" title="Direct link to Step 1: Set Up the Backend (5 Minutes)" translate="no">​</a></h3>
<p>First, you need the plugNmeet server, which includes LiveKit for media and NATS for messaging. You can install everything on a fresh Ubuntu server using our automated installation script.</p>
<div class="language-bash codeBlockContainer_fMmN theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_VhtC"><pre tabindex="0" class="prism-code language-bash codeBlock_H2kJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_yaRf"><span class="token-line" style="color:#393A34"><span class="token plain">wget https://raw.githubusercontent.com/mynaparrot/plugNmeet-install/main/install.sh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">chmod +x install.sh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">./install.sh</span><br></span></code></pre></div></div>
<p>That's it. You now have a production-ready media server and API endpoint. The script will provide you with your <code>API_KEY</code> and <code>API_SECRET</code>, which you'll need for the next step.</p>
<h3 class="anchor anchorTargetStickyNavbar_f97l" id="step-2-control-the-backend-with-an-api-call-10-minutes">Step 2: Control the Backend with an API Call (10 Minutes)<a href="https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour#step-2-control-the-backend-with-an-api-call-10-minutes" class="hash-link" aria-label="Direct link to Step 2: Control the Backend with an API Call (10 Minutes)" title="Direct link to Step 2: Control the Backend with an API Call (10 Minutes)" translate="no">​</a></h3>
<p>Next, you need to tell your backend to create a meeting room and generate a token for a user to join. This is done with a simple server-side API call.</p>
<p>You can use our official PHP SDK or JavaScript SDK, or call the API directly. Here’s a simple example in PHP:</p>
<div class="language-php codeBlockContainer_fMmN theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_VhtC"><pre tabindex="0" class="prism-code language-php codeBlock_H2kJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_yaRf"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;?php</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">require __DIR__ . "/plugNmeetConnect.php";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$config = new stdClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$config-&gt;plugnmeet_server_url = "https://demo.plugnmeet.com"; // Your server URL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$config-&gt;plugnmeet_api_key = "plugnmeet"; // Your API Key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$config-&gt;plugnmeet_secret = "zumyyYWqv7KR2kUqvYdq4z4sXg7XTBD2ljT6"; // Your API Secret</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$connect = new plugNmeetConnect($config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$roomId = "room01"; // Must be unique. You can also use $connect-&gt;getUUID();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$user_full_name = "John Doe";</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$userId = "your-unique-user-id"; // Must be unique for each user.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Define all the features for this specific room.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$roomMetadata = array(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    "room_features" =&gt; array(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        "allow_webcams" =&gt; true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        "mute_on_start" =&gt; false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        "allow_screen_share" =&gt; true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        "room_duration" =&gt; 0 // 0 = no limit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... and many more options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$create = $connect-&gt;createRoom($roomId, "Test room", "Welcome to room", 0, "", $roomMetadata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// $create-&gt;getStatus();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$join = $connect-&gt;getJoinToken($roomId, $user_full_name, $userId, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// $join-&gt;getStatus();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$url = $config-&gt;plugnmeet_server_url . "?access_token=" . $join-&gt;getToken();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo $url;</span><br></span></code></pre></div></div>
<p>This script creates a room and gives you a unique URL with a token that grants "John Doe" access to that room. You can find full example of PHP from <a class="" href="https://www.plugnmeet.org/docs/tutorials/quick_php">PHP Quick Start</a></p>
<h3 class="anchor anchorTargetStickyNavbar_f97l" id="step-3-display-the-frontend-2-minutes">Step 3: Display the Frontend (2 Minutes)<a href="https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour#step-3-display-the-frontend-2-minutes" class="hash-link" aria-label="Direct link to Step 3: Display the Frontend (2 Minutes)" title="Direct link to Step 3: Display the Frontend (2 Minutes)" translate="no">​</a></h3>
<p>Now for the final piece: the user interface. Do you need to build one from scratch? No.</p>
<p>plugNmeet provides a complete, feature-rich, and customizable web client. You simply need to direct your user to the join URL generated in the previous step.</p>
<p>The join URL looks something like this:
<code>https://your-domain.com/login.html?access_token=YOUR_GENERATED_TOKEN</code></p>
<p>When a user visits this link, the plugNmeet client application loads, authenticates them with the token, and places them directly into the video meeting.</p>
<hr>
<h2 class="anchor anchorTargetStickyNavbar_f97l" id="conclusion-youre-a-video-app-developer-now">Conclusion: You're a Video App Developer Now<a href="https://www.plugnmeet.org/blog/build-video-conferencing-app-in-under-an-hour#conclusion-youre-a-video-app-developer-now" class="hash-link" aria-label="Direct link to Conclusion: You're a Video App Developer Now" title="Direct link to Conclusion: You're a Video App Developer Now" translate="no">​</a></h2>
<p>In the time it took to read this article, you've learned the entire workflow:</p>
<ol>
<li class=""><strong>Install a powerful backend</strong> with a single command.</li>
<li class=""><strong>Use a simple API call</strong> to control rooms and users.</li>
<li class=""><strong>Use the pre-built client</strong> to provide an instant user interface.</li>
</ol>
<p>You've skipped the mountain of WebRTC complexity and gone straight to building your application. From here, you can use our <strong>Design Customization</strong> features to completely white-label the client, or use our webhooks to build complex business logic around your meetings.</p>
<p>The power of a complete WebRTC platform is now at your fingertips. What will you build?</p>
<hr>
<p><strong>Ready to get started?</strong></p>
<ul>
<li class=""><strong>Follow the <a class="" href="https://www.plugnmeet.org/docs/installation">Installation Guide</a></strong></li>
<li class=""><strong>Explore the <a class="" href="https://www.plugnmeet.org/docs/api/intro">API Documentation</a></strong></li>
</ul>]]></content:encoded>
            <category>webrtc</category>
            <category>api</category>
            <category>sdk</category>
            <category>developer</category>
            <category>tutorial</category>
            <category>programming</category>
        </item>
    </channel>
</rss>