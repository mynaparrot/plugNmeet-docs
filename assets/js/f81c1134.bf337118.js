"use strict";(self.webpackChunkplugnmeet_documentation=self.webpackChunkplugnmeet_documentation||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"backend-architecture-deep-dive","metadata":{"permalink":"/blog/backend-architecture-deep-dive","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-27-backend-architecture-deep-dive.md","source":"@site/blog/2025-10-27-backend-architecture-deep-dive.md","title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","description":"Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.","date":"2025-10-27T00:00:00.000Z","tags":[{"inline":true,"label":"webrtc","permalink":"/blog/tags/webrtc"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"backend","permalink":"/blog/tags/backend"},{"inline":true,"label":"livekit","permalink":"/blog/tags/livekit"},{"inline":true,"label":"nats","permalink":"/blog/tags/nats"},{"inline":true,"label":"open-source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"}],"readingTime":6.44,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","slug":"backend-architecture-deep-dive","authors":["jibon"],"tags":["webrtc","architecture","backend","livekit","nats","open-source","scalability"]},"unlisted":false,"nextItem":{"title":"How to Build Your Own Video Conferencing App in Under an Hour","permalink":"/blog/build-video-conferencing-app-in-under-an-hour"}},"content":"Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.\\n\\nWhen we designed plugNmeet, we had a clear set of goals: the platform needed to be high-performance, horizontally scalable, resilient, and easy for developers to build upon. This led us to make two fundamental decisions for our backend: we chose **LiveKit** for our media server and **NATS** for our real-time messaging layer.\\n\\nThis article is a deep dive into the \\"why\\" behind these critical choices.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Two Pillars of Real-Time Communication\\n\\nAt its core, any serious video conferencing platform has to solve two distinct problems. But for a project like plugNmeet, it\'s not enough to just make them work. The solution must also be:\\n\\n*   **Easy to Scale:** Able to grow from handling a few dozen users to many thousands without a complete re-architecture.\\n*   **Highly Available:** Resilient to failure, ensuring that the loss of a single component doesn\'t bring the entire system down.\\n*   **Resource-Efficient & Cost-Effective:** Designed to run on reasonable hardware, keeping operational costs low for everyone.\\n*   **Easy to Manage:** Simple to deploy and maintain, even for small teams or individual developers.\\n\\nOur architectural philosophy was to choose a best-in-class open-source tool for each of the two main challenges\u2014**Media Routing** and **Signaling**\u2014that met all of these demanding criteria.\\n\\n1.  **Media Routing:** How do you efficiently get audio and video streams from each participant to every other participant?\\n2.  **Signaling & State Management:** How do you instantly deliver all the other real-time information that makes a meeting dynamic and interactive?\\n\\n## Pillar 1: LiveKit - The High-Performance Media Engine\\n\\nIn the early days of WebRTC, many apps used a peer-to-peer (P2P) mesh. This works for a 1-on-1 call, but it fails catastrophically as you add more people. Each participant has to upload their video stream separately to every other person, quickly overwhelming their internet connection.\\n\\nThe modern solution is a **Selective Forwarding Unit (SFU)**. An SFU is a server that acts as a traffic cop. Each participant sends their video stream to the SFU just *once*, and the SFU then forwards that stream to all other participants.\\n\\nFor our SFU, we chose **LiveKit**, and here\u2019s why:\\n\\n*   **High Performance & Efficiency:** LiveKit is written in Go, making it incredibly fast and resource-efficient. It can handle a large number of concurrent users and streams on a single server, which aligns with our goal of providing a cost-effective solution.\\n*   **Built-in Scalability:** LiveKit is designed to be clustered, and it uses Redis to manage state across multiple nodes. This provides a clear, documented path to the massive scale required by our largest users.\\n*   **Modern Features by Default:** LiveKit comes with critical, out-of-the-box support for modern WebRTC features like **Simulcast** (sending multiple quality streams) and **Dynacast** (intelligently pausing streams). This allows plugNmeet to automatically adapt to each user\'s network conditions, dramatically improving reliability.\\n*   **Secure and Open Source:** As an open-source project itself, LiveKit aligns with our core philosophy of transparency. It also has built-in support for passing through End-to-End Encrypted (E2EE) media, which is essential for our security model.\\n\\nIn short, by building on top of LiveKit, we didn\'t have to reinvent the wheel. We inherited a powerful, battle-tested media engine, allowing us to focus on building the application logic and features that make plugNmeet unique.\\n\\n## Pillar 2: NATS JetStream - The Resilient Nervous System\\n\\nWhile LiveKit handles the heavy media streams, we needed a separate, highly reliable system for all the other real-time data that makes a meeting interactive. This is where **NATS** comes in.\\n\\nMore specifically, we leverage **NATS JetStream**, the powerful persistence layer built into the NATS ecosystem. JetStream elevates NATS from a simple messaging system to a true streaming platform, which is critical for the reliability and scalability of our backend services.\\n\\nHere\u2019s why JetStream was the perfect choice for plugNmeet:\\n\\n*   **Multi-Layered Security:** NATS provides a robust, defense-in-depth security model at the messaging layer, which operates in addition to our application-level E2EE.\\n    *   **Encryption in Transit:** All connections from clients to the NATS cluster are secured using **TLS**. This encrypts all signaling data while it\'s on the wire, protecting it from eavesdropping.\\n    *   **Fine-Grained Authorization:** This is where the real power lies. When a user authenticates, the `plugnmeet-server` dynamically generates a unique set of permissions for that specific user session. These permissions strictly define which NATS subjects the user is allowed to publish to and subscribe from, typically scoped by `roomId` and `userId`. This enforces a true **principle of least privilege**, making it architecturally impossible for a user in one room to access data from another.\\n\\n*   **Scalable Request Processing with Queue Workers:** For critical client-server interactions, like fetching the initial user list, we leverage JetStream\'s powerful **queue worker pattern**. When a client sends a request, it\'s published to a stream. Our backend `plugnmeet-server` instances subscribe to this stream as a **queue group**, and NATS ensures that each request is delivered to only **one** available server. This provides automatic, built-in load balancing for our core application logic.\\n\\n*   **High-Performance Streaming for Real-Time Data:** For other real-time data like **chat messages** or **collaborative whiteboard** drawing data, we use JetStream\'s high-performance streaming capabilities to ensure fast and reliable delivery to all participants in a room.\\n\\n*   **Built for Resilience:** NATS is designed from the ground up for clustering and self-healing. If one NATS node fails, clients will automatically reconnect to another, ensuring the \\"nervous system\\" of your meetings stays online.\\n\\nBy using NATS for its deep security model, performance, and resilience, we built a backend that is fast, secure, and remarkably easy to scale.\\n\\n---\\n\\n## Conclusion: A Foundation Built for the Future\\n\\nThe choice of LiveKit and NATS JetStream was deliberate. By combining a best-in-class media server with a best-in-class streaming platform, we\'ve created a platform that is:\\n\\n*   **Performant:** Handling both media and signaling with specialized, high-speed tools.\\n*   **Scalable:** With clear, documented paths for clustering each component.\\n*   **Resilient:** With built-in failover and self-healing capabilities.\\n*   **Flexible:** Allowing us to build powerful, decoupled features like our auto-scaling recorders.\\n\\nBut there\'s one more crucial element that ties this all together: **the underlying technology**. Both LiveKit and NATS are written in **Go**, one of the most powerful languages for modern, concurrent network services. This was no accident. We deliberately chose to write the core `plugnmeet-server` in Go as well.\\n\\nThis creates a **unified, high-performance ecosystem**. Our developers can move seamlessly between components, leading to faster development cycles, easier maintenance, and a more cohesive and stable platform for our users. It means that when you build with plugNmeet, you\'re building on a consistent and coherent technology stack from top to bottom.\\n\\nThe ultimate benefit of this Go-based approach is in the final deployment. The entire `plugnmeet-server` compiles down to a **single, dependency-free binary file**. This makes deployment incredibly simple and portable. You can run it as a standalone service on a bare-metal server or package it into a minimal, highly secure Docker container. There are no language runtimes to manage and no complex dependencies to install\u2014just a single file that works.\\n\\nWhen you choose plugNmeet, you\'re not just getting an application. You\'re getting a thoughtfully designed architecture built on a foundation you can trust.\\n\\n---\\n**Want to learn more?**\\n\\n*   **Read our [Scalable Deployment Guide](/docs/developer-guide/scalable-setup)**\\n*   **Explore the [Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**"},{"id":"build-video-conferencing-app-in-under-an-hour","metadata":{"permalink":"/blog/build-video-conferencing-app-in-under-an-hour","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-26-build-video-conferencing-app-in-under-an-hour.md","source":"@site/blog/2025-10-26-build-video-conferencing-app-in-under-an-hour.md","title":"How to Build Your Own Video Conferencing App in Under an Hour","description":"Building a video conferencing application sounds like a monumental task. You have to wrestle with the complexities of WebRTC, set up signaling servers, manage STUN/TURN for NAT traversal, and handle the resource-intensive job of routing media streams. The backend infrastructure alone can take months to build and stabilize.","date":"2025-10-26T00:00:00.000Z","tags":[{"inline":true,"label":"webrtc","permalink":"/blog/tags/webrtc"},{"inline":true,"label":"api","permalink":"/blog/tags/api"},{"inline":true,"label":"sdk","permalink":"/blog/tags/sdk"},{"inline":true,"label":"developer","permalink":"/blog/tags/developer"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"},{"inline":true,"label":"programming","permalink":"/blog/tags/programming"}],"readingTime":3.83,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"How to Build Your Own Video Conferencing App in Under an Hour","slug":"build-video-conferencing-app-in-under-an-hour","authors":["jibon"],"tags":["webrtc","api","sdk","developer","tutorial","programming"]},"unlisted":false,"prevItem":{"title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","permalink":"/blog/backend-architecture-deep-dive"}},"content":"Building a video conferencing application sounds like a monumental task. You have to wrestle with the complexities of WebRTC, set up signaling servers, manage STUN/TURN for NAT traversal, and handle the resource-intensive job of routing media streams. The backend infrastructure alone can take months to build and stabilize.\\n\\nBut what if you could skip all of that?\\n\\nWhat if you could leverage a powerful, open-source platform that handles all the backend complexity, allowing you to build a fully functional, custom-branded video conferencing app in under an hour? With **plugNmeet**, you can.\\n\\nThis guide will show you the three core steps to building your own video app using plugNmeet\'s API-first architecture.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Old Way: The Mountain of Complexity\\n\\nBefore we show you the easy way, it\'s important to appreciate the problems plugNmeet solves. Building a WebRTC app from scratch requires you to become an expert in:\\n\\n1.  **Signaling:** Creating a system (usually with WebSockets) to coordinate connections between users.\\n2.  **NAT Traversal:** Setting up and managing STUN/TURN servers to allow users behind firewalls to connect to each other.\\n3.  **Media Server (SFU):** Deploying and scaling a Selective Forwarding Unit (like LiveKit, Mediasoup, or Janus) to efficiently route video and audio streams.\\n4.  **Backend Logic:** Writing an application server to manage rooms, users, and permissions.\\n5.  **Frontend UI:** Building a complete user interface from scratch to handle video elements, buttons, chat, and more.\\n\\nThis is a massive undertaking.\\n\\n## The plugNmeet Way: An API-First Framework\\n\\nplugNmeet bundles all of this complexity into a single, open-source server that you can install with an automated script. It provides you with a simple, powerful set of APIs that act as your building blocks.\\n\\nHere\'s how you build your app in three steps.\\n\\n### Step 1: Set Up the Backend (5 Minutes)\\n\\nFirst, you need the plugNmeet server, which includes LiveKit for media and NATS for messaging. You can install everything on a fresh Ubuntu server using our automated installation script.\\n\\n```bash\\nwget https://raw.githubusercontent.com/mynaparrot/plugNmeet-install/main/install.sh\\nchmod +x install.sh\\n./install.sh\\n```\\n\\nThat\'s it. You now have a production-ready media server and API endpoint. The script will provide you with your `API_KEY` and `API_SECRET`, which you\'ll need for the next step.\\n\\n### Step 2: Control the Backend with an API Call (10 Minutes)\\n\\nNext, you need to tell your backend to create a meeting room and generate a token for a user to join. This is done with a simple server-side API call.\\n\\nYou can use our official PHP SDK or JavaScript SDK, or call the API directly. Here\u2019s a simple example in PHP:\\n\\n```php\\n<?php\\nrequire_once \'vendor/autoload.php\'; // Assuming you\'ve installed the SDK via Composer\\n\\nuse PlugNmeet\\\\auth\\\\Auth;\\nuse PlugNmeet\\\\plugNmeet;\\n\\n// Your API credentials from the server installation\\n$apiKey = \'plugnmeet\';\\n$apiSecret = \'zumyyYWqv7KR2kUqvYdq4z4sXg7XTBD2ljT6\';\\n$host = \'https://demo.plugnmeet.com\'; // Replace with your server URL\\n\\n$auth = new Auth($apiKey, $apiSecret);\\n$plugNmeet = new plugNmeet($host, $auth);\\n\\n// 1. Create a new room\\n$room = $plugNmeet->room()->createRoom([\\n    \'room_id\' => \'test-room-123\',\\n    \'max_participants\' => 20,\\n]);\\n\\n// 2. Generate a join token for a user\\n$token = $plugNmeet->auth()->getJoinToken([\\n    \'room_id\' => \'test-room-123\',\\n    \'user_info\' => [\\n        \'name\' => \'John Doe\',\\n        \'user_id\' => \'user-id-001\',\\n        \'is_admin\' => true,\\n    ],\\n]);\\n\\necho $token;\\n?>\\n```\\n\\nThis script creates a room and gives you a unique URL with a token that grants \\"John Doe\\" access to that room.\\n\\n### Step 3: Display the Frontend (2 Minutes)\\n\\nNow for the final piece: the user interface. Do you need to build one from scratch? No.\\n\\nplugNmeet provides a complete, feature-rich, and customizable web client. You simply need to direct your user to the join URL generated in the previous step.\\n\\nThe join URL looks something like this:\\n`https://your-domain.com/login.html?access_token=YOUR_GENERATED_TOKEN`\\n\\nWhen a user visits this link, the plugNmeet client application loads, authenticates them with the token, and places them directly into the video meeting.\\n\\n---\\n\\n## Conclusion: You\'re a Video App Developer Now\\n\\nIn the time it took to read this article, you\'ve learned the entire workflow:\\n\\n1.  **Install a powerful backend** with a single command.\\n2.  **Use a simple API call** to control rooms and users.\\n3.  **Use the pre-built client** to provide an instant user interface.\\n\\nYou\'ve skipped the mountain of WebRTC complexity and gone straight to building your application. From here, you can use our **Design Customization** features to completely white-label the client, or use our webhooks to build complex business logic around your meetings.\\n\\nThe power of a complete WebRTC platform is now at your fingertips. What will you build?\\n\\n---\\n**Ready to get started?**\\n\\n*   **Follow the [Installation Guide](/docs/installation)**\\n*   **Explore the [API Documentation](/docs/api/intro)**"}]}}')}}]);