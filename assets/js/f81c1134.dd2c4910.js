"use strict";(self.webpackChunkplugnmeet_documentation=self.webpackChunkplugnmeet_documentation||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"why-we-built-plugnmeet","metadata":{"permalink":"/blog/why-we-built-plugnmeet","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-31-why-we-built-plugnmeet.md","source":"@site/blog/2025-10-31-why-we-built-plugnmeet.md","title":"Why We Built Plug-N-Meet: A Founder\'s Story","description":"For years, our company has been a well-known provider of BigBlueButton hosting and support services. We\'ve deployed, managed, and scaled it for countless clients, and we have a deep respect for the role it has played in the open-source education community. It paved the way.","date":"2025-10-31T00:00:00.000Z","tags":[{"inline":true,"label":"open-source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"philosophy","permalink":"/blog/tags/philosophy"},{"inline":true,"label":"bigbluebutton","permalink":"/blog/tags/bigbluebutton"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"},{"inline":true,"label":"developer","permalink":"/blog/tags/developer"}],"readingTime":5.91,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"Why We Built Plug-N-Meet: A Founder\'s Story","slug":"why-we-built-plugnmeet","authors":["jibon"],"tags":["open-source","architecture","philosophy","bigbluebutton","scalability","developer"]},"unlisted":false,"nextItem":{"title":"The Anatomy of a Perfect Online Workshop: A Step-by-Step Guide","permalink":"/blog/anatomy-of-a-perfect-online-workshop"}},"content":"For years, our company has been a well-known provider of BigBlueButton hosting and support services. We\'ve deployed, managed, and scaled it for countless clients, and we have a deep respect for the role it has played in the open-source education community. It paved the way.\\n\\nBut after years in the trenches, supporting live sessions, online classes, and events at scale, we found ourselves running into the same fundamental walls. We weren\'t just using the software; we were experiencing its architectural limits firsthand. The frustration wasn\'t just about bugs; it was about an architecture that, while powerful for its original purpose, presented challenges for the kind of elastic scalability and developer agility that modern web applications demand.\\n\\nWe realized we had a choice: continue building workarounds, or take everything we had learned and build the solution we knew our users needed.\\n\\nWe chose to build. This is the story of why Plug-N-Meet exists.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### Lessons from the Trenches: The Challenges We Had to Solve\\n\\nOur decision wasn\'t born from a dislike of BigBlueButton, but from a deep understanding of its pain points at scale. We consistently faced a set of recurring challenges:\\n\\n*   **The 100-User Wall:** We saw time and again that even on powerful servers, BigBlueButton\'s performance would degrade significantly once a session crossed 100-150 concurrent users. It simply wasn\'t designed for the elastic scalability modern applications require.\\n\\n*   **The Labyrinth of Complexity:** The architecture is a mix of different programming languages and technologies, each solving a different piece of the puzzle. While brilliant in its time, this makes it incredibly difficult to maintain, debug, and\u2014most importantly\u2014add new features to. A simple change could have cascading effects across a half-dozen different services.\\n\\n*   **The Branding Straitjacket:** For our clients who wanted a true white-label experience, customization was a constant struggle. Deep branding required complex themeing and often direct code modifications, making every update a risky and time-consuming process.\\n\\n*   **The Recording Puzzle:** Recordings were a major pain point. The system was complex, and generating a single, portable MP4 file was notoriously difficult. In fact, I developed one of the first open-source solutions to try and solve this very problem, but even then, it was a patch on a fundamentally complicated system.\\n\\n*   **The Monolithic Burden:** The lack of modularity was the biggest roadblock. You couldn\'t scale one part of the system without scaling the whole thing. If recording was using all the CPU, it directly impacted live meetings. There was no separation of concerns.\\n\\n### A New Philosophy: Built on Simplicity, Modularity, and Control\\n\\nWith Plug-N-Meet, we started with a clean slate and a few core principles born directly from our frustrations.\\n\\n1.  **Radical Simplicity in Technology.**\\n    Instead of a dozen languages, we chose two: **Go** for the entire backend and **TypeScript (with React)** for the front-end. That\'s it. This decision extended to our core dependencies. We chose **LiveKit** as our media server and **NATS** for messaging, not just because they are best-in-class, but because they are also written in Go. This creates a unified, consistent, and high-performance ecosystem\u2014a topic we explore in our **[Backend Architecture Deep Dive](/blog/backend-architecture-deep-dive)**\u2014that is a joy for our developers to work in and easy for the community to contribute to.\\n\\n2.  **Modularity by Design.**\\n    Plug-N-Meet is not a monolith. It\'s a decoupled system of components that work together. The recorder, the media server, and the application logic are all separate. This means you can scale, update, or even replace one part without breaking everything else. Our new recorder\'s \\"Operational Modes\\" are a perfect example of this, a direct result of our **[recording philosophy](/blog/recording-philosophy)**. This allows you to run CPU-intensive transcoding on entirely different machines from your live recording servers, a concept we explore further in our **[Scalable Deployment Guide](/docs/developer-guide/scalable-setup)**.\\n\\n3.  **Effortless Customization.**\\n    Branding shouldn\'t be a development project. With Plug-N-Meet, deep customization is handled via a simple API and configuration objects. You can change colors, logos, and even the entire layout without ever touching our core code, as outlined in our **[Design Customization Guide](/docs/developer-guide/design-customisation)**, ensuring that your platform always feels like *your* platform.\\n\\n4.  **Empowering Everyone Through Integration.**\\n    While we provide powerful tools for developers, our philosophy has always been to make Plug-N-Meet accessible to everyone. A powerful platform shouldn\'t require a team of engineers to use. That\'s why we\'ve invested heavily in creating simple, robust plugins for the world\'s most popular CMS and LMS platforms.\\n\\n    With our official plugins for **WordPress**, **Moodle**, and **Joomla**, anyone can add a fully-featured, branded video conferencing service to their website in minutes. These integrations aren\'t just an afterthought; they are a core part of our mission to empower creators. As we\'ve detailed in our guides, you can even **[launch your own video service with WordPress](/blog/no-code-video-conferencing-service-with-wordpress)**, **[build a scalable e-learning platform with Moodle](/blog/secure-scalable-moodle-e-learning-platform)**, or **[start a no-code business with Joomla](/blog/no-code-video-conferencing-service-with-joomla)**, no coding required.\\n\\n5.  **Developer-First, Not an Afterthought.**\\n    We are not a domain-based solution that locks you into a rigid structure. We are an API-first platform designed to be a building block. Whether you use our simple plugins for WordPress and Moodle or our **[`getClientFiles` API](/docs/api/get-client-files)** for a \\"headless\\" integration, our goal is to empower you to build the exact experience you want, not force you into ours.\\n\\n6.  **Security as a Foundation, Not an Add-on.**\\n    In today\'s world, privacy is non-negotiable. We built Plug-N-Meet with a security-first mindset, offering robust **End-to-End Encryption (E2EE)** as a core feature, with multiple **[key management models](/blog/e2ee-key-models-guide)** to fit any security posture. This ensures that conversations are private and that not even the server can access the media streams. This commitment to privacy is woven through our entire architecture, as detailed in our **[Security Overview](/docs/security-overview)**.\\n\\n---\\n\\n### Conclusion: Building the Road for the Future\\n\\nWe will always be grateful for the path that BigBlueButton paved. It showed the world what was possible with open-source communication. But the web has evolved, and the demands for scalability, flexibility, and developer experience have grown exponentially.\\n\\nWe built Plug-N-Meet to answer that call. It is the platform we wished we had during all those years of managing complex deployments\u2014a simpler, more powerful, and more flexible foundation for the future of real-time communication.\\n\\nWe are not building a tool for everyone. We are building a **platform for builders.**\\n\\n---\\n\\n**Ready to see the difference for yourself?**\\n\\n*   **[Migrating from BigBlueButton? We\'ve made it easy.](/docs/tutorials/migration-from-bbb)**\\n*   **[Explore our API Documentation](/docs/api/intro)**\\n*   **[Explore the Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**\\n*   **[Try the Live Demo to experience the modern interface.](https://demo.plugnmeet.com/landing.html)**"},{"id":"anatomy-of-a-perfect-online-workshop","metadata":{"permalink":"/blog/anatomy-of-a-perfect-online-workshop","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-30-anatomy-of-a-perfect-online-workshop.md","source":"@site/blog/2025-10-30-anatomy-of-a-perfect-online-workshop.md","title":"The Anatomy of a Perfect Online Workshop: A Step-by-Step Guide","description":"We\'ve all been there: an \\"interactive workshop\\" that\'s just a 90-minute video call with a slide deck. The host struggles to juggle different apps for polls, group activities, and notes, while the audience slowly disengages.","date":"2025-10-30T00:00:00.000Z","tags":[{"inline":true,"label":"workshop","permalink":"/blog/tags/workshop"},{"inline":true,"label":"collaboration","permalink":"/blog/tags/collaboration"},{"inline":true,"label":"breakout-rooms","permalink":"/blog/tags/breakout-rooms"},{"inline":true,"label":"whiteboard","permalink":"/blog/tags/whiteboard"},{"inline":true,"label":"polling","permalink":"/blog/tags/polling"},{"inline":true,"label":"use-case","permalink":"/blog/tags/use-case"},{"inline":true,"label":"automation","permalink":"/blog/tags/automation"}],"readingTime":4.38,"hasTruncateMarker":true,"authors":[{"name":"Bob Teng","title":"Developer Advocate","url":"https://github.com/wbobteng","imageURL":"https://github.com/wbobteng.png","key":"bob","page":null}],"frontMatter":{"title":"The Anatomy of a Perfect Online Workshop: A Step-by-Step Guide","slug":"anatomy-of-a-perfect-online-workshop","authors":["bob"],"tags":["workshop","collaboration","breakout-rooms","whiteboard","polling","use-case","automation"]},"unlisted":false,"prevItem":{"title":"Why We Built Plug-N-Meet: A Founder\'s Story","permalink":"/blog/why-we-built-plugnmeet"},"nextItem":{"title":"Your Session, Your Browser: How We Use Client-Side Storage for Privacy and Resilience","permalink":"/blog/client-side-storage-privacy-resilience"}},"content":"We\'ve all been there: an \\"interactive workshop\\" that\'s just a 90-minute video call with a slide deck. The host struggles to juggle different apps for polls, group activities, and notes, while the audience slowly disengages.\\n\\nAn online workshop shouldn\'t be a passive presentation. It should be a dynamic, collaborative experience. But to achieve that, you need more than just a video link; you need an integrated toolkit where every feature works together seamlessly.\\n\\nWith Plug-N-Meet, you have that toolkit. This guide will walk you through the anatomy of a perfect online workshop, showing how to use a single, unified platform to manage every stage of your event, from the initial icebreaker to the automated follow-up.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### Step 1: The Blueprint - Setting Up Your Workshop for Success\\n\\nA great workshop starts with the right environment. When you create your Plug-N-Meet room, you\'re not just creating a call; you\'re setting the stage. Using the API or the dashboard, you can pre-configure the room specifically for interaction:\\n\\n*   **Enable Breakout Rooms:** Check the box to allow breakout rooms, ready for your group activities.\\n*   **Activate the Whiteboard:** Ensure the interactive whiteboard is enabled for visual collaboration.\\n*   **Keep it Open:** Unlike a formal webinar, you might start with microphones and webcams unlocked to encourage participation from the very beginning.\\n*   **Set Up Your Automation:** Provide a `webhook_url` during room creation. This is the secret ingredient for our automated follow-up later.\\n\\n### Step 2: The Icebreaker - A Visual Welcome\\n\\nForget the awkward \\"let\'s go around and say our names\\" in the chat. A great workshop starts with immediate, visual engagement.\\n\\n**The Activity:** Use the **Interactive Whiteboard** for a simple icebreaker. Upload an image of a world map. As participants join, enable **multi-user drawing mode** and ask everyone to place a dot or their name on the city they\'re joining from.\\n\\nIn seconds, you\'ve created a visual, interactive representation of your audience. It\'s a simple, powerful way to get everyone engaged and comfortable with the tools from the very first minute.\\n\\n### Step 3: The Core Activity - Deep Collaboration in Breakout Rooms\\n\\nNow for the heart of the workshop. You announce, \\"We\'re going to split into groups of four to brainstorm solutions.\\"\\n\\nWith Plug-N-Meet, this is effortless:\\n\\n1.  The host opens the **Breakout Rooms** management panel.\\n2.  They choose the number of rooms and the duration (e.g., \\"15 minutes\\").\\n3.  They can drag and drop participants into specific rooms or click **\\"Randomly Assign\\"** to have Plug-N-Meet do the work.\\n\\nThe magic is what happens *inside* these rooms. Unlike other platforms where advanced features disappear, each breakout room in Plug-N-Meet gets its own **fully functional, private interactive whiteboard and shared notepad.**\\n\\nYour groups can now brainstorm on their own canvas, create their own notes, and collaborate deeply without being distracted by the main session. As a host, you can even send a broadcast message to all rooms (\\"5 minutes left!\\") or pop into a specific room to see how they\'re doing.\\n\\n### Step 4: The Debrief - Gathering Insights with Live Polls\\n\\nThe breakout session timer ends, and everyone is automatically brought back to the main room. How do you efficiently gather the key takeaways from each group?\\n\\nThis is the perfect moment for a **Live Poll**.\\n\\nThe host creates a new poll on the fly: \\"Which proposed solution did your group find most promising?\\" with several options. As participants vote, the host sees the results update in real-time. Once the voting is closed, the host can click **\\"Publish Results,\\"** which sends a clean, graphical summary to the public chat for everyone to see and discuss. It\'s a structured, democratic, and highly efficient way to debrief.\\n\\n### Step 5: The Follow-Up - Smart, Automated Summaries\\n\\nThe workshop was a huge success. Now what? Manually downloading the recording, uploading it somewhere, and emailing a link to all attendees is a tedious, error-prone process.\\n\\nThis is where the `webhook_url` you set up in Step 1 comes into play.\\n\\n1.  The host clicks **\\"End Recording.\\"**\\n2.  A few minutes later, once the recording file is processed and ready, the Plug-N-Meet server automatically sends a notification (a webhook) to your server.\\n3.  Your system, listening for this `end_recording` event, receives a payload with the link to the downloadable MP4 file.\\n4.  Your server can then automatically trigger a pre-written email to all registered workshop attendees with a thank-you message and the link to the recording.\\n\\nThe host does nothing. The follow-up is instant, professional, and completely automated.\\n\\n---\\n\\n### Conclusion: An Integrated Toolkit for True Collaboration\\n\\nA successful online workshop isn\'t about having a dozen different tools; it\'s about having the *right* tools that work together in harmony.\\n\\nFrom the initial setup and interactive icebreaker, through the deep collaboration in breakout rooms, to the structured polling and automated follow-up, Plug-N-Meet provides a single, integrated platform designed for one purpose: to help you create more engaging, effective, and professional online events.\\n\\n---\\n\\n**Ready to host your best workshop yet?**\\n\\n*   **Try these features in our [Live Demo](https://demo.plugnmeet.com/landing.html)**\\n*   **Explore our [Webhooks Documentation](/docs/others/webhooks) to learn about automation**\\n*   **Check out the [Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**"},{"id":"client-side-storage-privacy-resilience","metadata":{"permalink":"/blog/client-side-storage-privacy-resilience","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-30-client-side-storage-philosophy.md","source":"@site/blog/2025-10-30-client-side-storage-philosophy.md","title":"Your Session, Your Browser: How We Use Client-Side Storage for Privacy and Resilience","description":"We\u2019ve all felt that moment of panic. You\u2019re in an important online meeting, the chat is full of crucial links, and then you accidentally hit refresh. Everything is gone. To solve this, many applications store your entire session on their backend servers. This allows them to restore your session, but it comes at a huge cost: your sensitive data is now stored permanently on someone else\'s hard drive.","date":"2025-10-30T00:00:00.000Z","tags":[{"inline":true,"label":"privacy","permalink":"/blog/tags/privacy"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"indexeddb","permalink":"/blog/tags/indexeddb"},{"inline":true,"label":"data-minimization","permalink":"/blog/tags/data-minimization"},{"inline":true,"label":"ux","permalink":"/blog/tags/ux"}],"readingTime":2.62,"hasTruncateMarker":true,"authors":[{"name":"Chaboud Simon","title":"Community & Marketing Lead","url":"https://github.com/saimonzone","imageURL":"https://github.com/saimonzone.png","key":"simon","page":null}],"frontMatter":{"title":"Your Session, Your Browser: How We Use Client-Side Storage for Privacy and Resilience","slug":"client-side-storage-privacy-resilience","authors":["simon"],"tags":["privacy","security","architecture","indexeddb","data-minimization","ux"]},"unlisted":false,"prevItem":{"title":"The Anatomy of a Perfect Online Workshop: A Step-by-Step Guide","permalink":"/blog/anatomy-of-a-perfect-online-workshop"},"nextItem":{"title":"Our Philosophy on Recordings: Why We Capture the Whole Picture","permalink":"/blog/recording-philosophy"}},"content":"We\u2019ve all felt that moment of panic. You\u2019re in an important online meeting, the chat is full of crucial links, and then you accidentally hit refresh. Everything is gone. To solve this, many applications store your entire session on their backend servers. This allows them to restore your session, but it comes at a huge cost: your sensitive data is now stored permanently on someone else\'s hard drive.\\n\\nAt plugNmeet, we believe this is the wrong trade-off. We\'ve made a deliberate architectural choice to use **your browser\'s own storage** to provide a resilient experience without compromising your privacy.\\n\\nOur philosophy is simple: **if we don\'t need the data on our server to make the service work, we don\'t touch it.**\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Problem: Server Databases are Data \\"Honeypots\\"\\n\\nMost applications link your in-meeting activity to an account. They save your chat history, your whiteboard drawings, and your preferences in a large backend database.\\n\\nWhile this can be convenient, it creates a massive \\"honeypot\\" of user data. This central database becomes a prime target for data breaches. If the server is ever compromised, all of that user information is at risk.\\n\\nWe believe this is an unnecessary risk for the kind of temporary data generated during a meeting.\\n\\n## The plugNmeet Solution: Your Browser is Your Temporary Database\\n\\nTo give you a smooth experience without compromising your privacy, we use your browser\'s built-in storage (IndexedDB) for temporary session information.\\n\\nThis means that when you\'re in a meeting, data like this is stored **only on your own computer**:\\n\\n*   **Your chat history** for the current session.\\n*   The state of the **collaborative whiteboard**.\\n*   Your chosen **subtitle language**, etc.\\n\\nOur backend server has no knowledge of this information. We use this local storage for one primary reason: to make your experience resilient by restoring your session if you accidentally refresh the page.\\n\\n### The Lifecycle of Your Data: Here Today, Gone Tomorrow\\n\\nThe data stored in your browser is designed to be temporary. Here\'s how we handle it in simple terms:\\n\\n1.  **When you leave a meeting properly,** all the session data we stored in your browser is **immediately and permanently deleted.**\\n\\n2.  **If you leave abnormally** (like closing the tab), the data remains temporarily to allow you to rejoin. However, the next time you start the application, a cleanup process automatically finds and **deletes this old data** after a few hours.\\n\\nThis ensures that your browser stays clean and your session data remains ephemeral.\\n\\n---\\n\\n## Conclusion: Privacy and Resilience by Design\\n\\nOur decision to use client-side storage is a core part of our \\"privacy by design\\" philosophy.\\n\\nBy not collecting and storing your in-meeting activity on our servers, we can make a simple but powerful promise: **we cannot lose, misuse, or be forced to hand over data that we do not have.**\\n\\nIt\'s a simple principle that leads to a more private, more secure, and more respectful platform for everyone. Your data stays where it belongs: with you.\\n\\n---\\n**Want to learn more about our security model?**\\n\\n*   **Read our complete [Security Overview](/docs/security-overview)**\\n*   **Explore the [Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**"},{"id":"recording-philosophy","metadata":{"permalink":"/blog/recording-philosophy","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-30-recording-philosophy.md","source":"@site/blog/2025-10-30-recording-philosophy.md","title":"Our Philosophy on Recordings: Why We Capture the Whole Picture","description":"What is a meeting recording? Is it just a collection of video and audio streams? Or is it a faithful replica of a live, interactive experience?","date":"2025-10-30T00:00:00.000Z","tags":[{"inline":true,"label":"recorder","permalink":"/blog/tags/recorder"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"ffmpeg","permalink":"/blog/tags/ffmpeg"},{"inline":true,"label":"headless-chrome","permalink":"/blog/tags/headless-chrome"},{"inline":true,"label":"philosophy","permalink":"/blog/tags/philosophy"},{"inline":true,"label":"reliability","permalink":"/blog/tags/reliability"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"}],"readingTime":4.14,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"Our Philosophy on Recordings: Why We Capture the Whole Picture","slug":"recording-philosophy","authors":["jibon"],"tags":["recorder","architecture","ffmpeg","headless-chrome","philosophy","reliability","scalability"]},"unlisted":false,"prevItem":{"title":"Your Session, Your Browser: How We Use Client-Side Storage for Privacy and Resilience","permalink":"/blog/client-side-storage-privacy-resilience"},"nextItem":{"title":"Who Holds the Keys? A Guide to plugNmeet\'s End-to-End Encryption Models","permalink":"/blog/e2ee-key-models-guide"}},"content":"What is a meeting recording? Is it just a collection of video and audio streams? Or is it a faithful replica of a live, interactive experience?\\n\\nAt Plug-N-Meet, we believe a recording should be a perfect, trustworthy artifact. When you watch it back, the whiteboard annotations should appear at the exact moment the speaker was discussing them. The chat messages should pop up in perfect sync with the conversation. The shared presentation should be exactly as the audience saw it.\\n\\nTo achieve this perfect fidelity, we made a deliberate architectural choice for our recorder: we record the **final, rendered output**, not just the individual parts. This article explains why this headless Chrome-based approach, while CPU-intensive, is fundamentally better and more reliable than the alternatives.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### The Alternative: The Fragile Puzzle of Component-Based Recording\\n\\nMany systems attempt to record meetings by capturing each data stream independently:\\n*   One file for each participant\'s audio.\\n*   Another file for each video stream.\\n*   A JSON or text file containing all the chat messages with timestamps.\\n*   A separate event log for all the whiteboard drawings, pointer movements, and slide changes.\\n\\nOn the surface, this seems efficient. But it creates a massive, fragile puzzle for post-processing. The system must then try to reassemble all these disparate pieces into a single, coherent video.\\n\\nThis approach is fraught with peril:\\n*   **Synchronization Nightmares:** What if a network hiccup causes a slight drift in the timestamps between the audio and the whiteboard events? The result is a recording where the presenter is pointing at something that isn\'t there yet.\\n*   **Complexity in Playback:** To view the \\"recording,\\" you often need a special player that knows how to read all these separate files and reconstruct the session on the fly. The final output isn\'t a simple, portable video file.\\n*   **Brittle and Not Future-Proof:** If you add a new feature to your client, like emoji reactions, you also have to update your entire recording-processing logic to know how to handle and display this new \\"part.\\"\\n\\nThis method doesn\'t create a recording; it creates a complex and fragile reconstruction that is only as good as its weakest link.\\n\\n### The Plug-N-Meet Way: Recording What You Actually See\\n\\nOur philosophy is simpler and far more robust. We believe the only way to perfectly capture a live event is to record it exactly as a human participant would experience it.\\n\\nHere\u2019s how we do it:\\n1.  When a recording is initiated, we launch a **\\"virtual participant\\"** into the meeting. This is a headless Chrome browser running on the server.\\n2.  This virtual user sees and hears everything exactly as a real person would. It sees the active speaker, the shared screen, the whiteboard drawings, and the chat messages as they appear, all rendered together in a single, final view.\\n3.  We then use the industry-standard `ffmpeg` to capture the output of this browser window, encoding it directly into a standard **MP4 video file**.\\n\\nThe result is a single, self-contained video file that is a **perfect, high-fidelity replica** of the live session. What you saw is what you get.\\n\\n### The Best of Both Worlds: Fidelity and Scalability\\n\\nWe are transparent about the trade-off: running a headless browser and encoding video in real-time is a CPU-intensive task. In our previous architecture, this could mean that a server busy with post-processing a finished recording might have fewer resources available for new, live recordings.\\n\\nWe have completely solved this.\\n\\nThe new `plugnmeet-recorder` introduces **Operational Modes**, allowing you to decouple the recording pipeline.\\n*   You can run lightweight **`recorderOnly`** instances whose sole job is to join the meeting and capture the raw, high-fidelity stream. They use minimal CPU and are always ready for the next live session.\\n*   You can then run a separate fleet of **`transcoderOnly`** workers on different, even cheaper, servers. Their only job is to perform the CPU-intensive post-processing, converting the raw files into the final MP4s.\\n\\nThis architecture gives you the best of both worlds: the perfect fidelity of a headless Chrome recording and the scalability to offload the intensive work, ensuring your live meetings are never impacted.\\n\\n---\\n\\n### Conclusion: A Commitment to Quality\\n\\nOur choice to use a headless browser for recordings is a direct reflection of our commitment to quality and reliability. A meeting recording is often a critical business asset or an essential educational resource. It needs to be perfect. By capturing the entire, rendered experience\u2014and providing a scalable architecture to manage the workload\u2014we ensure that your recordings are not just a collection of parts, but a trustworthy and professional record of what actually happened.\\n\\n---\\n\\n**Ready to dive deeper into our recording architecture?**\\n\\n*   **[Explore the plugNmeet-recorder on GitHub](https://github.com/mynaparrot/plugNmeet-recorder)**\\n*   **[Read our Scalable Deployment Guide](/docs/developer-guide/scalable-setup) to see how to use the new operational modes.**\\n*   **[Try the Live Demo to create a recording yourself](https://demo.plugnmeet.com/landing.html)**"},{"id":"e2ee-key-models-guide","metadata":{"permalink":"/blog/e2ee-key-models-guide","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-29-e2ee-key-models-guide.md","source":"@site/blog/2025-10-29-e2ee-key-models-guide.md","title":"Who Holds the Keys? A Guide to plugNmeet\'s End-to-End Encryption Models","description":"In the world of secure communication, End-to-End Encryption (E2EE) is the gold standard. It ensures that only the participants in a conversation can decrypt and view the media streams, not even the server itself. At plugNmeet, we\'ve implemented a robust E2EE model based on the WebRTC Insertable Streams API.","date":"2025-10-29T00:00:00.000Z","tags":[{"inline":true,"label":"e2ee","permalink":"/blog/tags/e-2-ee"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"encryption","permalink":"/blog/tags/encryption"},{"inline":true,"label":"privacy","permalink":"/blog/tags/privacy"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"developer","permalink":"/blog/tags/developer"}],"readingTime":4.51,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"Who Holds the Keys? A Guide to plugNmeet\'s End-to-End Encryption Models","slug":"e2ee-key-models-guide","authors":["jibon"],"tags":["e2ee","security","encryption","privacy","architecture","developer"]},"unlisted":false,"prevItem":{"title":"Our Philosophy on Recordings: Why We Capture the Whole Picture","permalink":"/blog/recording-philosophy"},"nextItem":{"title":"A Major Leap Forward: Announcing the Next Generation of Plug-N-Meet","permalink":"/blog/plugnmeet-next-generation"}},"content":"In the world of secure communication, End-to-End Encryption (E2EE) is the gold standard. It ensures that only the participants in a conversation can decrypt and view the media streams, not even the server itself. At plugNmeet, we\'ve implemented a robust E2EE model based on the WebRTC Insertable Streams API.\\n\\nBut \\"E2EE\\" isn\'t a single, one-size-fits-all solution. A critical question remains: **where do the encryption keys come from, and who manages them?**\\n\\nplugNmeet offers two distinct models for managing E2EE keys, controlled by a simple setting: `enabled_self_insert_encryption_key`. Understanding the difference is key to choosing the right security posture for your application.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Core Concept: Shared Secret\\n\\nIn both models, the goal is the same: every participant in a room must share the exact same secret key. This key is used to encrypt all outgoing media and decrypt all incoming media. If a user doesn\'t have the key, they can\'t participate.\\n\\nThe difference between our two models comes down to a simple question: **who generates and distributes this shared secret?**\\n\\n### Model 1: Server-Generated Keys (`enabled_self_insert_encryption_key = false`)\\n\\nThis is the **default, simplest, and most convenient** method.\\n\\n**How it works:**\\n1.  When the first participant joins an E2EE-enabled room, the **plugNmeet server** cryptographically generates a strong, random secret key for that specific room.\\n2.  As each subsequent participant joins, the plugNmeet server securely delivers this key to the new participant as part of their authentication response.\\n3.  The client\'s browser then uses this key to set up its encryption mechanism.\\n\\n**Who is this for?**\\n*   **Most standard use cases.**\\n*   Applications that need strong encryption without the complexity of building their own key management system.\\n*   Anyone who trusts their own self-hosted plugNmeet server to manage keys on a per-session basis.\\n\\n**Pros:**\\n*   **Simple to Implement:** E2EE works out of the box with no extra development work required on your part.\\n*   **Secure:** The key is generated on your trusted, self-hosted server and transmitted securely to each client. It only exists for the duration of the session.\\n\\n**The Trust Model:**\\nIn this model, you are trusting your own plugNmeet server to generate and distribute the keys. The server \\"knows\\" the key for each session, but it is designed not to store it long-term. For a self-hosted environment, this is a very strong and practical security model.\\n\\n---\\n\\n### Model 2: User-Provided Keys (`enabled_self_insert_encryption_key = true`)\\n\\nThis is the **most secure and advanced** method, providing a true \\"zero-knowledge\\" architecture where not even your application handles the key.\\n\\n**How it works:**\\n1.  When this mode is enabled, the plugNmeet server **does not** generate or handle any keys.\\n2.  It becomes the users\' responsibility to securely share a secret key among themselves using a completely **out-of-band channel** (e.g., a Signal message, a password manager, or even verbally). Your application and servers never touch or see this key.\\n3.  When a user joins the meeting, the plugNmeet UI will **prompt them to manually enter the secret key**.\\n4.  The user must type or paste the pre-shared key into the prompt. Only if the key is correct will their client be able to encrypt and decrypt the media streams to participate in the call.\\n\\n**Who is this for?**\\n*   **Maximum Security & Zero-Knowledge Applications:** Use cases where you need to guarantee that your entire server infrastructure (including both the plugNmeet server and your own application backend) has absolutely no knowledge of the encryption keys.\\n*   **Journalist/Whistleblower Platforms:** Situations where proving that you cannot access user communications is a core feature.\\n*   **High-Assurance Enterprise Meetings:** For top-secret internal discussions where keys are managed by corporate security policy, not the application.\\n\\n**Pros:**\\n*   **True Zero-Knowledge:** Your servers are completely blind to the content of the conversations. The key never touches your server infrastructure, not even your application\'s frontend.\\n*   **Maximum User Control:** The security of the key is entirely in the hands of the end-users and their chosen out-of-band communication method.\\n\\n**The Trust Model:**\\nIn this model, you are not trusting any server component at all. You are only trusting the end-user clients and the security of the out-of-band mechanism they used to share the key. This is the highest level of user-controlled security you can achieve.\\n\\n---\\n\\n## Quick Comparison: Which Model Should You Use?\\n\\n| Use Case                                      | Recommended Model        | Why?                                                                                             |\\n| :-------------------------------------------- | :----------------------- | :----------------------------------------------------------------------------------------------- |\\n| **A general-purpose meeting platform**        | **Server-Generated**     | Simple, secure, and requires no extra work. The default choice for most applications.            |\\n| **A secure telehealth or legal app**          | **User-Provided**        | Provides the strongest \\"zero-knowledge\\" guarantee, which may be required for compliance.         |\\n| **A private chat for a small, trusted team**  | **Server-Generated**     | The security is more than sufficient, and the convenience is high.                               |\\n| **Building a Signal/Telegram-like video app** | **User-Provided**        | Aligns with the user-controlled, zero-knowledge philosophy of those platforms.                   |\\n\\n## Conclusion\\n\\nThe choice between server-generated and user-provided keys is a classic trade-off between convenience and absolute control. By offering both models, plugNmeet gives you the flexibility to choose the security posture that best fits your application\'s specific needs and threat model.\\n\\nWhether you need the simple, out-of-the-box security of server-generated keys or the zero-knowledge guarantees of a user-provided model, plugNmeet provides the tools to build a truly secure communication platform.\\n\\n---\\n**Ready to learn more?**\\n\\n*   **Read our [Security Overview](/docs/security-overview)**\\n*   **Explore the [API Documentation](/docs/api/intro)**"},{"id":"plugnmeet-next-generation","metadata":{"permalink":"/blog/plugnmeet-next-generation","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-29-plugnmeet-next-generation.md","source":"@site/blog/2025-10-29-plugnmeet-next-generation.md","title":"A Major Leap Forward: Announcing the Next Generation of Plug-N-Meet","description":"We are thrilled to announce a landmark update for the Plug-N-Meet ecosystem, featuring a completely redesigned client and a more powerful, scalable recorder. These updates are the result of countless hours of development aimed at enhancing user experience, boosting performance, and providing developers with even more flexibility.","date":"2025-10-29T00:00:00.000Z","tags":[{"inline":true,"label":"release","permalink":"/blog/tags/release"},{"inline":true,"label":"update","permalink":"/blog/tags/update"},{"inline":true,"label":"react","permalink":"/blog/tags/react"},{"inline":true,"label":"vite","permalink":"/blog/tags/vite"},{"inline":true,"label":"recorder","permalink":"/blog/tags/recorder"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"},{"inline":true,"label":"developer","permalink":"/blog/tags/developer"},{"inline":true,"label":"ui-ux","permalink":"/blog/tags/ui-ux"}],"readingTime":5.17,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"A Major Leap Forward: Announcing the Next Generation of Plug-N-Meet","slug":"plugnmeet-next-generation","authors":["jibon"],"tags":["release","update","react","vite","recorder","scalability","developer","ui-ux"]},"unlisted":false,"prevItem":{"title":"Who Holds the Keys? A Guide to plugNmeet\'s End-to-End Encryption Models","permalink":"/blog/e2ee-key-models-guide"},"nextItem":{"title":"How to Launch Your Own Video Conferencing Service with Joomla (No Code Required)","permalink":"/blog/no-code-video-conferencing-service-with-joomla"}},"content":"We are thrilled to announce a landmark update for the Plug-N-Meet ecosystem, featuring a completely redesigned client and a more powerful, scalable recorder. These updates are the result of countless hours of development aimed at enhancing user experience, boosting performance, and providing developers with even more flexibility.\\n\\nWe\'re aiming to publish the new client **before Christmas**, but you don\'t have to wait to see what\'s coming. You can preview the future right now! Just click the **\\"Demo\\"** link from our website\'s main menu and select the **\\"Development version\\"** to get a sneak peek.\\n\\nLet\'s dive into what\u2019s new.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### **The New Client: A Completely Reimagined Experience**\\n\\nWe have rebuilt the Plug-N-Meet front-end from the ground up to be lighter, faster, and more intuitive than ever before.\\n\\n**A Fresh, Modern UI**\\n\\nThe first thing you\'ll notice is the stunning new user interface. Every component, from the control bar to the settings panel, has been redesigned for a cleaner look, smoother animations, and a more logical workflow. The result is a user experience that is not just more aesthetically pleasing, but also easier to navigate.\\n\\n**Under the Hood: A Blazing-Fast and Developer-Friendly Core**\\n\\nThis isn\'t just a facelift. We\'ve modernized the entire tech stack for a massive performance boost and a superior developer experience:\\n*   **Upgraded to React 19:** Leveraging the latest features from the React framework for a more efficient UI.\\n*   **Next-Generation Whiteboard:** We\'ve integrated the newest version of Excalidraw for a more feature-rich and responsive collaborative experience.\\n*   **Vite with Rolldown:** We have migrated our build system from Webpack to the cutting-edge Vite, powered by Rolldown. This means significantly faster development builds and a more optimized, lightweight production bundle.\\n*   **A Refactored & Modernized Codebase:** The entire client has been architecturally improved, making the code cleaner, more modular, and easier for developers to understand, customize, and contribute to.\\n*   **Zero-Knowledge Security Models:** The new client brings to life our most advanced security options, including support for `enabled_self_insert_encryption_key`. This allows users to provide their own encryption keys for a true zero-knowledge session, a feature we detailed in our [guide to E2EE key models](/blog/e2ee-key-models-guide).\\n*   ...and many more improvements!\\n\\n#### **What This Upgrade Means For You**\\n\\nWe\'ve worked hard to make this transition as smooth as possible.\\n\\n*   **For Users of Our Official Plugins (WordPress, Moodle, Joomla):**\\n    You don\'t need to worry about a thing. Simply update the plugin from your platform\'s marketplace after you\'ve updated your Plug-N-Meet server. The new client will be loaded automatically.\\n\\n*   **For Developers with Custom Integrations (`getClientFiles`):**\\n    This is a critical update. To achieve the new performance standards, the client now utilizes modern **ES Modules**. This requires a small but important change to how you inject the JavaScript files into your application.\\n\\n    **The Core Logic (Language-Agnostic):**\\n    Previously, all JavaScript files could be loaded with a standard `<script>` tag. Now, you must differentiate between the main module script and the other scripts.\\n\\n    1.  When you loop through the `js_files` array returned by the API, you need to check the filename of each script.\\n    2.  If the filename **starts with `main-module.`**, you must render its `<script>` tag with `type=\\"module\\"`.\\n    3.  For all other JavaScript files, you should render the `<script>` tag as before, preferably with a `defer` attribute to avoid blocking page render.\\n\\n    This logic can be implemented in any server-side language or templating engine (Python, Node.js, Ruby, etc.) by performing a simple string check on the filename.\\n\\n    **Implementation Example (PHP):**\\n    Here is a PHP example demonstrating how to implement this conditional logic:\\n\\n    ```php\\n    <?php foreach ($api_response[\'js\'] as $js_file): ?>\\n        <?php if (str_starts_with($js_file, \'main-module.\')):\\n            <script src=\\"<?php echo $assets_path . \'/js/\' . $js_file ?>\\" type=\\"module\\"><\/script>\\n        <?php else: ?>\\n            <script src=\\"<?php echo $assets_path . \'/js/\' . $js_file ?>\\" defer=\\"defer\\"><\/script>\\n        <?php endif; ?>\\n    <?php endforeach; ?>\\n    ```\\n\\n    By following this logic, you can ensure the new, faster client loads correctly in your custom application.\\n\\n---\\n\\n### **The New Recorder: A Scalable & Resilient Pipeline**\\n\\nOne of the most common bottlenecks in any live video platform is recording. Previously, as soon as a recording ended, the same server that was handling live meetings would begin the CPU-intensive task of post-processing (transcoding), which could impact the performance of other active sessions.\\n\\nWith the new `plugnmeet-recorder`, we\'ve completely solved this problem by introducing **Operational Modes**.\\n\\nEach recorder instance can now be configured to run as a specialized worker, allowing you to build a powerful, decoupled, and highly scalable recording pipeline.\\n\\n*   **`recorderOnly` Mode:** This worker\'s only job is to record the live session to a raw file. Once finished, it publishes a \\"transcoding job\\" to a queue and immediately frees itself up to record another session. It never gets bogged down by post-processing.\\n\\n*   **`transcoderOnly` Mode:** This worker does the heavy lifting. It subscribes to the job queue, picks up transcoding tasks one by one, and converts the raw files into the final MP4 format.\\n\\n*   **`both` Mode (Default):** For smaller setups, a single instance can still perform both functions, just as it did before.\\n\\n#### **Why This is a Game-Changer**\\n\\nThis new architecture allows you to build a truly professional-grade recording system:\\n*   **Scalability:** You can run a fleet of `transcoderOnly` workers on separate, cheaper VMs, processing dozens of recordings in parallel without ever affecting the performance of your live meetings.\\n*   **Resilience:** If a `transcoderOnly` worker fails, the job simply remains in the queue until another worker picks it up. No recordings are lost.\\n*   **Performance:** Your `recorderOnly` workers stay lightweight and responsive, ensuring the quality of your live session recordings is never compromised by CPU load.\\n\\n---\\n\\n### **Conclusion**\\n\\nThis release marks a significant step forward in our mission to provide the most powerful, flexible, and high-performance open-source video conferencing platform. The redesigned client delivers a world-class user experience, while the new recorder architecture provides the scalability and resilience needed for enterprise-grade deployments.\\n\\nWe can\'t wait for you to experience the new Plug-N-Meet.\\n\\n**Ready to upgrade?**\\n\\n*   **[Explore the Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**\\n*   **[Review the updated API Documentation](/docs/api/get-client-files)**\\n*   **[Check out the Live Demo to see the new UI in action](https://demo.plugnmeet.com/landing.html)**"},{"id":"no-code-video-conferencing-service-with-joomla","metadata":{"permalink":"/blog/no-code-video-conferencing-service-with-joomla","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-28-no-code-video-conferencing-service-with-joomla.md","source":"@site/blog/2025-10-28-no-code-video-conferencing-service-with-joomla.md","title":"How to Launch Your Own Video Conferencing Service with Joomla (No Code Required)","description":"Have you ever dreamed of launching your own online service or \\"micro-SaaS,\\" but felt blocked by the biggest hurdle: coding? You\'re not alone. The idea of building, managing, and scaling a software product is daunting.","date":"2025-10-28T00:00:00.000Z","tags":[{"inline":true,"label":"joomla","permalink":"/blog/tags/joomla"},{"inline":true,"label":"no-code","permalink":"/blog/tags/no-code"},{"inline":true,"label":"business","permalink":"/blog/tags/business"},{"inline":true,"label":"saas","permalink":"/blog/tags/saas"},{"inline":true,"label":"monetization","permalink":"/blog/tags/monetization"},{"inline":true,"label":"white-label","permalink":"/blog/tags/white-label"},{"inline":true,"label":"component","permalink":"/blog/tags/component"}],"readingTime":4.85,"hasTruncateMarker":true,"authors":[{"name":"Chaboud Simon","title":"Community & Marketing Lead","url":"https://github.com/saimonzone","imageURL":"https://github.com/saimonzone.png","key":"simon","page":null}],"frontMatter":{"title":"How to Launch Your Own Video Conferencing Service with Joomla (No Code Required)","slug":"no-code-video-conferencing-service-with-joomla","authors":["simon"],"tags":["joomla","no-code","business","saas","monetization","white-label","component"]},"unlisted":false,"prevItem":{"title":"A Major Leap Forward: Announcing the Next Generation of Plug-N-Meet","permalink":"/blog/plugnmeet-next-generation"},"nextItem":{"title":"How to Launch Your Own Video Conferencing Service with WordPress (No Code Required)","permalink":"/blog/no-code-video-conferencing-service-with-wordpress"}},"content":"Have you ever dreamed of launching your own online service or \\"micro-SaaS,\\" but felt blocked by the biggest hurdle: coding? You\'re not alone. The idea of building, managing, and scaling a software product is daunting.\\n\\nBut what if you could create a fully branded, monetized, and professional video conferencing service using a tool you already know and trust?\\n\\nWith the power of Joomla and the **plugNmeet** component, you can. This guide will walk you through the simple, step-by-step process of launching your own white-label video conferencing service, without writing a single line of code.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### The \\"No-Code\\" Tech Stack: The Three Simple Pieces\\n\\nTo build your service, you only need three things:\\n\\n1.  **A Joomla Website:** Your command center and storefront.\\n2.  **The Plug-N-Meet Joomla Component:** The free tool that integrates video conferencing directly into your site.\\n3.  **A Plug-N-Meet Server:** The engine that powers your video calls.\\n\\nThat\'s it. Let\'s get started.\\n\\n### Step 1: Get Your Video Conferencing Engine (The Power of Ownership)\\n\\nThe \\"engine\\" is the server that handles all the complex video and audio processing. For ultimate control, privacy, and cost-effectiveness, the best path is to **self-host the open-source Plug-N-Meet server**. This gives you complete ownership of your platform and data. Thanks to our automated installation script, you can get a production-ready server running on a fresh Ubuntu instance with just a few commands.\\n\\nHowever, if your goal is to get started instantly without touching a command line, the official **[plugNmeet Cloud](https://www.plugnmeet.cloud)** service is the perfect \\"no-code\\" alternative. You can sign up for a free account to test your service and get your credentials immediately.\\n\\nWhether you choose to self-host or use the cloud, you will get an **API Key** and **API Secret**. Think of these credentials as the keys to your video engine. Keep them safe!\\n\\n### Step 2: Integrate into Joomla (The 5-Minute Setup)\\n\\nNow, let\'s connect your engine to your Joomla site.\\n\\n1.  From your Joomla administrator panel, navigate to **System > Install > Extensions**.\\n2.  Select the **Install from Web** tab and search for **\\"plugnmeet\\"**.\\n3.  Find the official Plug-N-Meet component and click **Install**.\\n4.  After installation, navigate to **System > Global Configuration** and select **plugNmeet** from the components list.\\n5.  Carefully copy your **API Key** and **API Secret** from your server and paste them into the corresponding fields.\\n\\nClick **Save**. Congratulations, you now have a fully functional video conferencing platform running directly on your Joomla site.\\n\\n### Step 3: Create Your \\"Product\\" - The Meeting Rooms\\n\\nYour \\"product\\" is the different types of meeting rooms you will offer.\\n\\n1.  From the Joomla administrator panel, go to **Components > Plug N Meet > Manage Rooms**.\\n2.  Click **+ New** and define your service offering. For example:\\n    *   **\\"Basic Meeting Room\\":** Limit to 10 participants and a 60-minute duration.\\n    *   **\\"Premium Webinar Room\\":** Allow up to 100 participants, unlimited duration, and enable **Cloud Recording**.\\n\\nBy enabling or disabling features, you can easily create different value tiers. Once you\'ve configured a room, click **Save**.\\n\\n### Step 4: Monetize It - Putting a Price Tag on Your Rooms\\n\\nThis is where your business comes to life. Joomla\'s built-in Access Control Levels (ACL) and the plugNmeet component\'s permissions work together perfectly here.\\n\\nThe workflow is simple:\\n\\n1.  **Use a Joomla Membership Extension:** Install a membership or e-commerce extension. Use it to create subscription plans (e.g., \\"Silver Tier,\\" \\"Gold Tier\\") that automatically assign paying customers to specific Joomla user groups.\\n2.  **Create a Premium Menu Item:** Navigate to **Menus > Main Menu** and click **+ Add New Menu Item**.\\n3.  For the **Menu Item Type**, select **Plug N Meet > Single room**.\\n4.  In the **Select a room** dropdown, choose the \\"Premium Webinar Room\\" you created.\\n5.  **Restrict Access:** This is the key step where you define what different user tiers can do.\\n    *   **Control Room Access:** In the menu item\'s settings, set the **Access** level to your paid user groups (e.g., \\"Silver Tier\\" and \\"Gold Tier\\"). Now, only paying subscribers will be able to see and access the meeting room.\\n    *   **Control Feature Access:** Go to **Components > Plug N Meet > Manage Rooms** and edit your premium room. In the **Permission** tab, you can set even more granular rules. For example, you could allow your \\"Gold Tier\\" members to both watch and **download recordings**, while \\"Silver Tier\\" members can only stream them.\\n\\nThis powerful combination allows you to create sophisticated subscription models with fine-grained control over who can access what content and features. You\'ve successfully created a paywall for your premium video service.\\n\\n### Step 5: Brand It and Make It Your Own\\n\\nFinally, make the service look like yours.\\n\\n1.  Navigate to **System > Global Configuration > plugNmeet**.\\n2.  Go to the **Design Customization** tab.\\n3.  Here, you can upload your own logo and change the primary and secondary colors to match your brand identity.\\n\\nIn just a few clicks, you\'ve transformed the user interface into a completely white-labeled experience.\\n\\n---\\n\\n### Conclusion: You\'re a SaaS Founder Now\\n\\nLet\'s recap. In less than an hour, using only Joomla and a membership extension, you have:\\n\\n*   Launched a fully functional video conferencing service.\\n*   Created tiered products with different features.\\n*   Integrated a payment system to monetize your service.\\n*   Customized the branding to make it completely your own.\\n\\nYou didn\'t just add a feature to your website; you built a business. This is the power of the no-code movement combined with flexible, API-first platforms like plugNmeet. You are no longer just renting a generic tool\u2014you own the platform.\\n\\n---\\n\\n**Ready to launch your own video service on Joomla?**\\n\\n*   **[Explore the Open-Source Project and Installation Guide](/docs/installation)**\\n*   **[Find the official Joomla Component on the JED](https://extensions.joomla.org/extension/plugnmeet/)**\\n*   **Try the [Live Demo](https://demo.plugnmeet.com/landing.html) to see what your users will experience**"},{"id":"no-code-video-conferencing-service-with-wordpress","metadata":{"permalink":"/blog/no-code-video-conferencing-service-with-wordpress","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-28-no-code-video-conferencing-service-with-wordpress.md","source":"@site/blog/2025-10-28-no-code-video-conferencing-service-with-wordpress.md","title":"How to Launch Your Own Video Conferencing Service with WordPress (No Code Required)","description":"Have you ever dreamed of launching your own online service or \\"micro-SaaS,\\" but felt blocked by the biggest hurdle: coding? You\'re not alone. The idea of building, managing, and scaling a software product is daunting.","date":"2025-10-28T00:00:00.000Z","tags":[{"inline":true,"label":"wordpress","permalink":"/blog/tags/wordpress"},{"inline":true,"label":"no-code","permalink":"/blog/tags/no-code"},{"inline":true,"label":"business","permalink":"/blog/tags/business"},{"inline":true,"label":"saas","permalink":"/blog/tags/saas"},{"inline":true,"label":"monetization","permalink":"/blog/tags/monetization"},{"inline":true,"label":"white-label","permalink":"/blog/tags/white-label"},{"inline":true,"label":"plugin","permalink":"/blog/tags/plugin"}],"readingTime":4.63,"hasTruncateMarker":true,"authors":[{"name":"Chaboud Simon","title":"Community & Marketing Lead","url":"https://github.com/saimonzone","imageURL":"https://github.com/saimonzone.png","key":"simon","page":null}],"frontMatter":{"title":"How to Launch Your Own Video Conferencing Service with WordPress (No Code Required)","slug":"no-code-video-conferencing-service-with-wordpress","authors":["simon"],"tags":["wordpress","no-code","business","saas","monetization","white-label","plugin"]},"unlisted":false,"prevItem":{"title":"How to Launch Your Own Video Conferencing Service with Joomla (No Code Required)","permalink":"/blog/no-code-video-conferencing-service-with-joomla"},"nextItem":{"title":"Looking for Open Source Webinar Software? Here\u2019s Why You Need a Platform, Not Just a Tool.","permalink":"/blog/open-source-webinar-software-platform"}},"content":"Have you ever dreamed of launching your own online service or \\"micro-SaaS,\\" but felt blocked by the biggest hurdle: coding? You\'re not alone. The idea of building, managing, and scaling a software product is daunting.\\n\\nBut what if you could create a fully branded, monetized, and professional video conferencing service using a tool you probably already use every day?\\n\\nWith the power of WordPress and the **plugNmeet** plugin, you can. This guide will walk you through the simple, step-by-step process of launching your own white-label video conferencing service, without writing a single line of code.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### The \\"No-Code\\" Tech Stack: The Three Simple Pieces\\n\\nTo build your service, you only need three things:\\n\\n1.  **A WordPress Website:** Your command center and storefront.\\n2.  **The Plug-N-Meet WordPress Plugin:** The free tool that integrates video conferencing directly into your site.\\n3.  **A Plug-N-Meet Server:** The engine that powers your video calls.\\n\\nThat\'s it. Let\'s get started.\\n\\n### Step 1: Get Your Video Conferencing Engine (The Power of Ownership)\\n\\nThe \\"engine\\" is the server that handles all the complex video and audio processing. For ultimate control, privacy, and cost-effectiveness, the best path is to **self-host the open-source Plug-N-Meet server**. This gives you complete ownership of your platform and data. Thanks to our automated installation script, you can get a production-ready server running on a fresh Ubuntu instance with just a few commands.\\n\\nHowever, if your goal is to get started instantly without touching a command line, the official **[plugNmeet Cloud](https://www.plugnmeet.cloud)** service is the perfect \\"no-code\\" alternative. You can sign up for a free account to test your service and get your credentials immediately.\\n\\nWhether you choose to self-host or use the cloud, you will get an **API Key** and **API Secret**. Think of these credentials as the keys to your video engine. Keep them safe!\\n\\n### Step 2: Integrate into WordPress (The 5-Minute Setup)\\n\\nNow, let\'s connect your engine to your WordPress site.\\n\\n1.  From your WordPress dashboard, go to **Plugins > Add New**.\\n2.  Search for **\\"plugnmeet\\"** and click **Install Now**, then **Activate**.\\n3.  A new \\"Plug-N-Meet\\" menu will appear. Go to **Plug-N-Meet > Settings**.\\n4.  Carefully copy your **API Key** and **API Secret** from your server and paste them into the corresponding fields in the plugin settings.\\n\\nClick **Save Changes**. Congratulations, you now have a fully functional video conferencing platform running directly on your WordPress site.\\n\\n### Step 3: Create Your \\"Product\\" - The Meeting Rooms\\n\\nYour \\"product\\" is the different types of meeting rooms you will offer. You can create different tiers or packages.\\n\\n1.  Go to **Plug-N-Meet > Rooms** and click **Add New**.\\n2.  Here, you can define your service offering. For example:\\n    *   **\\"Basic Meeting Room\\":** Maybe this has a limit of 10 participants and a 60-minute duration.\\n    *   **\\"Premium Webinar Room\\":** This could allow up to 100 participants, have an unlimited duration, and have **Cloud Recording** enabled.\\n\\nBy enabling or disabling features like recording, you can easily create different value tiers for your service. Once you\'ve configured a room, click **Submit**.\\n\\n### Step 4: Monetize It - Putting a Price Tag on Your Rooms\\n\\nThis is where your business comes to life. To sell access to your rooms, you can use a popular (and often free) WordPress e-commerce or membership plugin. For this example, we\'ll use the concept behind plugins like **WooCommerce** or **Paid Memberships Pro**.\\n\\nThe workflow is simple:\\n\\n1.  **Create a \\"Product\\" or \\"Membership Level\\"** in your chosen e-commerce plugin. For example, a \\"Pro Monthly Subscription\\" that costs $20/month.\\n2.  **Create a new Page** in WordPress for your premium meeting room (e.g., a page named \\"Pro Members\' Weekly Call\\").\\n3.  **Paste the Shortcode:** Go back to **Plug-N-Meet > Rooms**, copy the shortcode for your \\"Premium Webinar Room,\\" and paste it into the content of your new page.\\n4.  **Restrict Access:** This is the key step. Use your e-commerce plugin\'s functionality to restrict access to this new page so that **only users who have purchased the \\"Pro Monthly Subscription\\" can view it.**\\n\\nNow, when a non-paying user tries to visit the page, they\'ll be prompted to subscribe. When a paying member visits, they\'ll see the login form for their exclusive meeting room. You\'ve successfully created a paywall for your video service.\\n\\n### Step 5: Brand It and Make It Your Own\\n\\nFinally, make the service look like yours.\\n\\n1.  Go to **Plug-N-Meet > Settings** and scroll down to **Design Customization**.\\n2.  Here, you can upload your own logo and change the primary and secondary colors to match your brand identity.\\n\\nIn just a few clicks, you\'ve transformed the user interface into a completely white-labeled experience.\\n\\n---\\n\\n### Conclusion: You\'re a SaaS Founder Now\\n\\nLet\'s recap. In less than an hour, using only WordPress and free plugins, you have:\\n\\n*   Launched a fully functional video conferencing service.\\n*   Created tiered products with different features.\\n*   Integrated a payment system to monetize your service.\\n*   Customized the branding to make it completely your own.\\n\\nYou didn\'t just add a feature to your website; you built a business. This is the power of the no-code movement combined with flexible, API-first platforms like plugNmeet. You are no longer just renting a generic tool\u2014you own the platform.\\n\\n---\\n\\n**Ready to launch your own video service?**\\n\\n*   **[Explore the Open-Source Project and Installation Guide](/docs/installation)**\\n*   **[Download the official WordPress Plugin](https://wordpress.org/plugins/plugnmeet/)**\\n*   **Try the [Live Demo](https://demo.plugnmeet.com/landing.html) to see what your users will experience**"},{"id":"open-source-webinar-software-platform","metadata":{"permalink":"/blog/open-source-webinar-software-platform","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-28-open-source-webinar-software-platform.md","source":"@site/blog/2025-10-28-open-source-webinar-software-platform.md","title":"Looking for Open Source Webinar Software? Here\u2019s Why You Need a Platform, Not Just a Tool.","description":"When you search for open source webinar software, you\'re looking for more than just a way to talk to people online. You\'re looking for control. You want to own your brand, manage your audience, and create a unique, professional presentation without being locked into the expensive, rigid ecosystem of proprietary tools like Zoom Webinars or GoToWebinar.","date":"2025-10-28T00:00:00.000Z","tags":[{"inline":true,"label":"webinar","permalink":"/blog/tags/webinar"},{"inline":true,"label":"open-source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"business","permalink":"/blog/tags/business"},{"inline":true,"label":"marketing","permalink":"/blog/tags/marketing"},{"inline":true,"label":"saas-alternative","permalink":"/blog/tags/saas-alternative"},{"inline":true,"label":"platform","permalink":"/blog/tags/platform"}],"readingTime":5.35,"hasTruncateMarker":true,"authors":[{"name":"Bob Teng","title":"Developer Advocate","url":"https://github.com/wbobteng","imageURL":"https://github.com/wbobteng.png","key":"bob","page":null}],"frontMatter":{"title":"Looking for Open Source Webinar Software? Here\u2019s Why You Need a Platform, Not Just a Tool.","slug":"open-source-webinar-software-platform","authors":["bob"],"tags":["webinar","open-source","business","marketing","saas-alternative","platform"]},"unlisted":false,"prevItem":{"title":"How to Launch Your Own Video Conferencing Service with WordPress (No Code Required)","permalink":"/blog/no-code-video-conferencing-service-with-wordpress"},"nextItem":{"title":"Meet Users Where They Are: Why We Build Plugins, Not Another Standalone App","permalink":"/blog/plugin-first-philosophy"}},"content":"When you search for **open source webinar software**, you\'re looking for more than just a way to talk to people online. You\'re looking for control. You want to own your brand, manage your audience, and create a unique, professional presentation without being locked into the expensive, rigid ecosystem of proprietary tools like Zoom Webinars or GoToWebinar.\\n\\nMany open-source projects offer a basic meeting experience. But a webinar is not just a meeting. It has a different structure, different roles, and different goals. You need a platform that understands this distinction.\\n\\nAt plugNmeet, we believe the best webinar experience isn\'t a one-size-fits-all tool. It\'s a flexible, API-first platform that gives you the building blocks to create the *exact* webinar workflow you need. This article explains how.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## What Makes a Webinar Different?\\n\\nA webinar is a performance. It has a cast, a stage, and an audience. This requires a specific set of features that a standard meeting tool often lacks:\\n\\n1.  **Clear Roles:** You need a clear distinction between presenters (who can speak and share their screen) and attendees (who primarily listen and watch).\\n2.  **Audience Engagement Tools:** You need structured ways for the audience to interact, like Q&A sessions, polls, and hand-raising.\\n3.  **A Branded \\"Stage\\":** The experience should feel like your event, with your branding, not a generic third-party application.\\n4.  **Post-Webinar Automation:** The recording is a valuable asset. You need to be able to access it easily and automate what happens next.\\n\\nHere\u2019s how plugNmeet is architected to deliver on all four points.\\n\\n## 1. The Digital Green Room: Unmatched Control for Hosts and Presenters\\n\\nWith most webinar software, you\'re stuck with rigid, predefined roles. plugNmeet provides a flexible, multi-layered system that separates the job of **moderating the audience** from the job of **presenting the content**.\\n\\n*   **How We Solve It:**\\n    1.  **You Pre-Configure the Rules:** Before the webinar begins, you decide the default experience for your attendees. When creating a room via our API, you can pass a `default_lock_settings` object to start with everything locked down: microphones, webcams, screen sharing, etc. This creates a secure \\"digital green room\\" where your audience joins in a listen-only mode by default.\\n\\n    2.  **The Admin Moderates the Audience:** The user designated as `is_admin: true` has full control over the audience. During the live event, the admin can:\\n        *   **Unlock a feature globally:** For example, unlock the chat for everyone during a Q&A session.\\n        *   **Grant permission individually:** Click on a specific attendee\'s name and allow them to unmute their microphone to ask a question, without giving them any other privileges.\\n\\n    3.  **The Presenter Controls the Content:** The admin can designate any user as the **Presenter**. This is a special role focused on content delivery. The Presenter has unique abilities that no one else has, not even the admin, such as:\\n        *   Uploading PDF or Office documents to the whiteboard.\\n        *   Changing pages on an uploaded document for everyone to see.\\n\\nThis separation of roles is incredibly powerful. Your main speaker (the Presenter) can focus on delivering their content, while a separate host (the Admin) can focus on managing the audience, fielding questions, and ensuring the event runs smoothly. It\'s a system designed for a professional, team-run webinar.\\n\\n## 2. Beyond Chat: Structured Engagement with Polls and Q&A\\n\\nIn a large webinar, using the main chat for questions is a recipe for chaos. Important questions get buried in a flood of \\"hellos\\" and general comments. A professional event requires professional tools for audience interaction.\\n\\n*   **How We Solve It:** plugNmeet provides tools designed for structured engagement, moving beyond a simple chat window.\\n    *   **Live Polls for Q&A and Quizzes:** This is the perfect tool for structured interaction. The host can create a poll on the fly with multiple options, essentially creating a live quiz or a Q&A session. Attendees vote, and the host sees the results update in real-time. When the poll ends, the host can **publish the results**, sharing a clean, graphical summary with the entire audience. This is a clean, manageable, and professional way to gauge opinion or get answers to specific questions.\\n    *   **Raise Hand:** For moderated verbal questions, attendees can use the \\"Raise Hand\\" feature to get the host\'s attention without interrupting the speaker.\\n    *   **Chat for Messaging:** The chat remains available for general messaging and file sharing, keeping it separate from the structured Q&A happening in the polls.\\n\\n## 3. Your Stage, Your Brand\\n\\nYour webinar is your show. It shouldn\'t look and feel like a Zoom meeting.\\n\\n*   **How We Solve It:** As we detailed in our post on true white-labeling, plugNmeet offers deep customization. You can change the colors, add your logo, and even use our `getClientFiles` API to completely rebuild the layout, creating a fully branded, seamless experience for your audience.\\n\\n## 4. The After-Show: Owning Your Content\\n\\nWith SaaS platforms, your recording is often trapped on their cloud, subject to their retention policies and pricing.\\n\\n*   **How We Solve It:** With plugNmeet, you own your content. Recordings are saved directly to your own server. And with our `end_recording` webhook, you can build powerful post-webinar automations. For example, you can automatically:\\n    *   Upload the recording to your YouTube channel.\\n    *   Add the video to a \\"past webinars\\" section on your website.\\n    *   Send an email to all attendees with a link to the recording.\\n\\n---\\n\\n## Conclusion: Stop Searching for a Tool, Start Building on a Platform\\n\\nWhen you search for **open source webinar software**, don\'t settle for a rigid, pre-built tool that forces you into its workflow.\\n\\nChoose a platform.\\n\\nplugNmeet provides the flexible, powerful, and open-source foundation you need to build a professional, branded, and automated webinar experience that is truly your own.\\n\\nAnd if you\'re running your community on a platform like **WordPress or Joomla**, the journey is even easier. We have ready-to-use, official plugins that integrate all of this power directly into your existing website in minutes, no coding required.\\n\\nWhether you\'re a developer building a custom application from scratch or a site administrator looking for a simple, powerful integration, plugNmeet provides the tools to help you create the perfect webinar experience.\\n\\n---\\n**Ready to build your perfect webinar platform?**\\n\\n*   **Try our [Live Demo](https://demo.plugnmeet.com/landing.html) to see the features in action**\\n*   **Explore our [Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**\\n*   **Read our [API Documentation](/docs/api/intro) to start building**"},{"id":"plugin-first-philosophy","metadata":{"permalink":"/blog/plugin-first-philosophy","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-28-plugin-first-philosophy.md","source":"@site/blog/2025-10-28-plugin-first-philosophy.md","title":"Meet Users Where They Are: Why We Build Plugins, Not Another Standalone App","description":"If you manage a Learning Management System (LMS) like Moodle or a Content Management System (CMS) like WordPress, you\'ve likely faced this frustrating scenario: you have a vibrant community, a rich content library, and a well-defined user base, but the moment you need to host a live class or a webinar, you have to send everyone away to a third-party, standalone application.","date":"2025-10-28T00:00:00.000Z","tags":[{"inline":true,"label":"plugin","permalink":"/blog/tags/plugin"},{"inline":true,"label":"lms","permalink":"/blog/tags/lms"},{"inline":true,"label":"cms","permalink":"/blog/tags/cms"},{"inline":true,"label":"moodle","permalink":"/blog/tags/moodle"},{"inline":true,"label":"wordpress","permalink":"/blog/tags/wordpress"},{"inline":true,"label":"integration","permalink":"/blog/tags/integration"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"}],"readingTime":3.59,"hasTruncateMarker":true,"authors":[{"name":"Chaboud Simon","title":"Community & Marketing Lead","url":"https://github.com/saimonzone","imageURL":"https://github.com/saimonzone.png","key":"simon","page":null}],"frontMatter":{"title":"Meet Users Where They Are: Why We Build Plugins, Not Another Standalone App","slug":"plugin-first-philosophy","authors":["simon"],"tags":["plugin","lms","cms","moodle","wordpress","integration","architecture"]},"unlisted":false,"prevItem":{"title":"Looking for Open Source Webinar Software? Here\u2019s Why You Need a Platform, Not Just a Tool.","permalink":"/blog/open-source-webinar-software-platform"},"nextItem":{"title":"Building a Secure and Scalable E-Learning Platform with Plug-N-Meet and Moodle","permalink":"/blog/secure-scalable-moodle-e-learning-platform"}},"content":"If you manage a Learning Management System (LMS) like Moodle or a Content Management System (CMS) like WordPress, you\'ve likely faced this frustrating scenario: you have a vibrant community, a rich content library, and a well-defined user base, but the moment you need to host a live class or a webinar, you have to send everyone away to a third-party, standalone application.\\n\\nYou generate a Zoom link, post it on your site, and hope your users can find it, log in correctly, and navigate back when it\'s over. This experience is clunky, disjointed, and it breaks the seamless learning environment you\'ve worked so hard to build.\\n\\nAt plugNmeet, we believe this is a fundamentally flawed workflow. That\'s why we made a deliberate architectural choice: to be a **plugin-first platform**, not just another standalone app.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Friction of the Standalone App\\n\\nStandalone video conferencing tools are powerful, but when used alongside an existing platform, they create unnecessary friction:\\n\\n1.  **The Jarring Context Switch:** Sending users to an external domain is a disruptive experience. You lose control over the branding, the user journey, and you pull your users out of the very ecosystem you want them to engage with.\\n\\n2.  **The User Management Nightmare:** Your LMS or CMS already has a robust user database with roles and permissions. A standalone video app forces you to manage a second, parallel set of users, or to build and maintain a complex single sign-on (SSO) integration.\\n\\n3.  **The Siloed Data:** When a meeting is over, where does the recording go? Where are the chat logs? With a standalone app, this valuable data is trapped on a third-party cloud, completely disconnected from the course, article, or user group it belongs to.\\n\\n## Our Philosophy: A Deeply Integrated Communication Layer\\n\\nWe believe that for platforms like Moodle, WordPress, or Joomla, video conferencing shouldn\'t be a separate destination. It should be a **native feature**, a deeply integrated communication layer.\\n\\nBy focusing on plugins, we allow you to:\\n\\n*   **Leverage Your Existing Infrastructure:** Our plugins use your existing user database. A teacher in Moodle is a teacher in plugNmeet. A student is a student. There are no new accounts to create and no complex authentication to manage. It just works.\\n\\n*   **Create a Seamless User Experience:** Users never have to leave your domain. They join a live class directly from the course page. They participate in a webinar without ever seeing a third-party logo. The entire experience feels like a natural extension of your own platform.\\n\\n*   **Keep Data Contextual and Connected:** When a meeting is recorded, the recording automatically appears on the relevant course page in Moodle. The data belongs to the context in which it was created, making it easy for users to find and for you to manage.\\n\\n### A Real-World Example: The Moodle Workflow\\n\\nImagine a teacher setting up a live class. With the plugNmeet plugin:\\n\\n1.  She is already logged into her Moodle course.\\n2.  She clicks \\"Add an activity or resource\\" and selects \\"plugNmeet.\\"\\n3.  She sets the time and a few parameters, and the meeting is created.\\n\\nFor the student, the process is even simpler. They log into their course, see the link for the live session, and click it. They are instantly and securely joined to the meeting. There are no new tabs, no external apps to launch, and no confusion.\\n\\nThis is the power of a plugin-first approach.\\n\\n---\\n\\n## Our Commitment to the Ecosystem\\n\\nWe are not trying to build a separate island for your users to visit. We are building the bridges that bring powerful, self-hosted video communication directly into the platforms you already use and trust.\\n\\nOur Moodle plugin is just the beginning. Our vision is for plugNmeet to be the native, self-hosted video layer for every major LMS and CMS. We are actively working to expand our ecosystem of plugins and welcome community contributions to bring plugNmeet to even more platforms.\\n\\nplugNmeet isn\'t a destination; it\'s a feature. It\'s the communication layer your platform has been missing.\\n\\n---\\n**Ready to integrate powerful video into your platform?**\\n\\n*   **Check out our [Moodle Plugin](/docs/user-guide/moodle-integration)**\\n*   **Explore our Open-Source Project on [GitHub](https://github.com/mynaparrot/plugNmeet-server)**\\n*   **Read our [API Documentation](/docs/api/intro) to build your own integration**"},{"id":"secure-scalable-moodle-e-learning-platform","metadata":{"permalink":"/blog/secure-scalable-moodle-e-learning-platform","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-28-secure-scalable-moodle-e-learning-platform.md","source":"@site/blog/2025-10-28-secure-scalable-moodle-e-learning-platform.md","title":"Building a Secure and Scalable E-Learning Platform with Plug-N-Meet and Moodle","description":"For educators and institutions using Moodle, the goal is to create a seamless, engaging, and secure learning environment. However, when it\'s time for a live virtual class, many are forced to send their students to an external, generic video conferencing link. This experience is often disjointed, and the tools provided are frequently limited to passive screen sharing.","date":"2025-10-28T00:00:00.000Z","tags":[{"inline":true,"label":"moodle","permalink":"/blog/tags/moodle"},{"inline":true,"label":"e-learning","permalink":"/blog/tags/e-learning"},{"inline":true,"label":"education","permalink":"/blog/tags/education"},{"inline":true,"label":"whiteboard","permalink":"/blog/tags/whiteboard"},{"inline":true,"label":"collaboration","permalink":"/blog/tags/collaboration"},{"inline":true,"label":"excalidraw","permalink":"/blog/tags/excalidraw"},{"inline":true,"label":"security","permalink":"/blog/tags/security"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"}],"readingTime":4.32,"hasTruncateMarker":true,"authors":[{"name":"Bob Teng","title":"Developer Advocate","url":"https://github.com/wbobteng","imageURL":"https://github.com/wbobteng.png","key":"bob","page":null}],"frontMatter":{"title":"Building a Secure and Scalable E-Learning Platform with Plug-N-Meet and Moodle","slug":"secure-scalable-moodle-e-learning-platform","authors":["bob"],"tags":["moodle","e-learning","education","whiteboard","collaboration","excalidraw","security","scalability"]},"unlisted":false,"prevItem":{"title":"Meet Users Where They Are: Why We Build Plugins, Not Another Standalone App","permalink":"/blog/plugin-first-philosophy"},"nextItem":{"title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","permalink":"/blog/backend-architecture-deep-dive"}},"content":"For educators and institutions using Moodle, the goal is to create a seamless, engaging, and secure learning environment. However, when it\'s time for a live virtual class, many are forced to send their students to an external, generic video conferencing link. This experience is often disjointed, and the tools provided are frequently limited to passive screen sharing.\\n\\nWhat if your live classroom felt like a native part of Moodle? What if you could move beyond one-way screen sharing to a truly interactive and collaborative canvas, all while maintaining the highest levels of security and performance?\\n\\nBy integrating the **plugNmeet** activity module into Moodle, you can achieve exactly that. This post explores how to leverage plugNmeet\'s powerful, built-in collaborative tools\u2014the interactive whiteboard and shared notepad\u2014to build a superior e-learning platform.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n### Beyond Screen Sharing: The Interactive Whiteboard as a Presentation Tool\\n\\nScreen sharing is a one-way street. It\u2019s a passive experience where students watch you click through slides. An interactive whiteboard, however, is a two-way conversation.\\n\\nOur whiteboard, powered by the excellent **Excalidraw** engine, is more than just a blank canvas; it\'s a dynamic teaching surface. Its most powerful feature for educators is the ability to **upload Microsoft Office or LibreOffice documents (like PowerPoint, Word, or Excel) directly onto the canvas.**\\n\\nHere\u2019s how it transforms a standard lesson:\\n\\n1.  An instructor uploads their existing PowerPoint presentation.\\n2.  plugNmeet automatically converts each slide into a high-resolution image and places it on the whiteboard, arranged in the correct page order.\\n3.  The instructor can then navigate through the slides with a simple next/previous page interface, just like in native presentation software. They can draw, annotate, and highlight key concepts directly on top of their slides, creating a much more engaging and dynamic presentation.\\n\\nBut it doesn\'t stop there. As a moderator, you have full classroom control. With a single click, you can switch to **multi-user drawing mode**, allowing students to collaboratively solve a problem, annotate a diagram, or brainstorm ideas directly on the shared canvas.\\n\\n### The Digital Scratchpad: Collaborative Note-Taking with the Shared Notepad\\n\\nComplementing the visual nature of the whiteboard is the **Shared Notepad**. Powered by the robust and proven **Etherpad-lite** engine, this tool provides a real-time, collaborative text editor within the meeting.\\n\\nIt\u2019s the perfect digital scratchpad for:\\n\\n*   Taking collective class notes that everyone can contribute to and save.\\n*   Brainstorming lists and ideas in a structured text format.\\n*   Sharing and collaboratively editing snippets of code or text.\\n\\nThe notepad provides a persistent space for text-based collaboration, ensuring that no ideas are lost.\\n\\n### The Engine Under the Hood: Secure, Scalable, and Fast\\n\\nThese collaborative features are not just bolted on; they are powered by a backend architecture designed for performance and security.\\n\\n*   **Instant Synchronization:** All whiteboard annotations\u2014every line, shape, and text box\u2014are synchronized across all participants in near real-time. This is made possible by our high-performance **NATS JetStream** messaging system, which ensures a smooth, lag-free experience.\\n\\n*   **Secure by Design:** This rapid synchronization works perfectly even with **End-to-End Encryption (E2EE) enabled** for the whiteboard. You can have a highly interactive and collaborative session with the peace of mind that all visual data is fully encrypted.\\n\\n*   **Scalable Foundation:** This architecture is designed to scale, ensuring these features work just as seamlessly with a large class as they do with a small group.\\n\\n*(Note: While the whiteboard supports E2EE, the Etherpad-lite engine for the shared notepad does not currently operate under the E2EE model.)*\\n\\n### A Native Moodle Experience\\n\\nThe best part is that all of this functionality is available as a **native Moodle activity**. Because plugNmeet is designed for deep integration, users never leave your Moodle site. There are no jarring redirects to an external URL; the entire virtual classroom loads directly within your course page, creating a truly seamless experience that feels like a natural part of your platform.\\n\\nThis is made possible by our unique architecture, which leverages an API like `getClientFiles`. Instead of trapping the classroom in a restrictive `<iframe>`, this API allows the Moodle plugin to load the client\'s components directly. This not only provides a native feel but also enables powerful, on-the-fly customization. From the Moodle plugin settings, you can instantly adjust brand colors and change logos, creating a fully white-labeled experience without ever touching a line of code or worrying about the underlying complexity. It reinforces your brand, simplifies the user journey, and keeps all learning activities tightly integrated within your platform.\\n\\n---\\n\\n### Conclusion: Build a Better Classroom\\n\\nBy combining Moodle with plugNmeet, you are not just adding a video link to your course; you are building a truly integrated, secure, and scalable e-learning platform. You are empowering your educators with tools that are far more engaging than passive screen sharing, fostering a new level of collaboration and interaction in the virtual classroom.\\n\\n---\\n\\n**Ready to build your next-generation e-learning platform?**\\n\\n*   **Learn more about our [Moodle Integration](/docs/user-guide/moodle-integration)**\\n*   **Try the whiteboard and other features in our [Live Demo](https://demo.plugnmeet.com/landing.html)**\\n*   **Explore our [Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**"},{"id":"backend-architecture-deep-dive","metadata":{"permalink":"/blog/backend-architecture-deep-dive","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-27-backend-architecture-deep-dive.md","source":"@site/blog/2025-10-27-backend-architecture-deep-dive.md","title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","description":"Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.","date":"2025-10-27T00:00:00.000Z","tags":[{"inline":true,"label":"webrtc","permalink":"/blog/tags/webrtc"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"backend","permalink":"/blog/tags/backend"},{"inline":true,"label":"livekit","permalink":"/blog/tags/livekit"},{"inline":true,"label":"nats","permalink":"/blog/tags/nats"},{"inline":true,"label":"open-source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"}],"readingTime":6.44,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","slug":"backend-architecture-deep-dive","authors":["jibon"],"tags":["webrtc","architecture","backend","livekit","nats","open-source","scalability"]},"unlisted":false,"prevItem":{"title":"Building a Secure and Scalable E-Learning Platform with Plug-N-Meet and Moodle","permalink":"/blog/secure-scalable-moodle-e-learning-platform"},"nextItem":{"title":"How to Build Your Own Video Conferencing App in Under an Hour","permalink":"/blog/build-video-conferencing-app-in-under-an-hour"}},"content":"Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.\\n\\nWhen we designed plugNmeet, we had a clear set of goals: the platform needed to be high-performance, horizontally scalable, resilient, and easy for developers to build upon. This led us to make two fundamental decisions for our backend: we chose **LiveKit** for our media server and **NATS** for our real-time messaging layer.\\n\\nThis article is a deep dive into the \\"why\\" behind these critical choices.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Two Pillars of Real-Time Communication\\n\\nAt its core, any serious video conferencing platform has to solve two distinct problems. But for a project like plugNmeet, it\'s not enough to just make them work. The solution must also be:\\n\\n*   **Easy to Scale:** Able to grow from handling a few dozen users to many thousands without a complete re-architecture.\\n*   **Highly Available:** Resilient to failure, ensuring that the loss of a single component doesn\'t bring the entire system down.\\n*   **Resource-Efficient & Cost-Effective:** Designed to run on reasonable hardware, keeping operational costs low for everyone.\\n*   **Easy to Manage:** Simple to deploy and maintain, even for small teams or individual developers.\\n\\nOur architectural philosophy was to choose a best-in-class open-source tool for each of the two main challenges\u2014**Media Routing** and **Signaling**\u2014that met all of these demanding criteria.\\n\\n1.  **Media Routing:** How do you efficiently get audio and video streams from each participant to every other participant?\\n2.  **Signaling & State Management:** How do you instantly deliver all the other real-time information that makes a meeting dynamic and interactive?\\n\\n## Pillar 1: LiveKit - The High-Performance Media Engine\\n\\nIn the early days of WebRTC, many apps used a peer-to-peer (P2P) mesh. This works for a 1-on-1 call, but it fails catastrophically as you add more people. Each participant has to upload their video stream separately to every other person, quickly overwhelming their internet connection.\\n\\nThe modern solution is a **Selective Forwarding Unit (SFU)**. An SFU is a server that acts as a traffic cop. Each participant sends their video stream to the SFU just *once*, and the SFU then forwards that stream to all other participants.\\n\\nFor our SFU, we chose **LiveKit**, and here\u2019s why:\\n\\n*   **High Performance & Efficiency:** LiveKit is written in Go, making it incredibly fast and resource-efficient. It can handle a large number of concurrent users and streams on a single server, which aligns with our goal of providing a cost-effective solution.\\n*   **Built-in Scalability:** LiveKit is designed to be clustered, and it uses Redis to manage state across multiple nodes. This provides a clear, documented path to the massive scale required by our largest users.\\n*   **Modern Features by Default:** LiveKit comes with critical, out-of-the-box support for modern WebRTC features like **Simulcast** (sending multiple quality streams) and **Dynacast** (intelligently pausing streams). This allows plugNmeet to automatically adapt to each user\'s network conditions, dramatically improving reliability.\\n*   **Secure and Open Source:** As an open-source project itself, LiveKit aligns with our core philosophy of transparency. It also has built-in support for passing through End-to-End Encrypted (E2EE) media, which is essential for our security model.\\n\\nIn short, by building on top of LiveKit, we didn\'t have to reinvent the wheel. We inherited a powerful, battle-tested media engine, allowing us to focus on building the application logic and features that make plugNmeet unique.\\n\\n## Pillar 2: NATS JetStream - The Resilient Nervous System\\n\\nWhile LiveKit handles the heavy media streams, we needed a separate, highly reliable system for all the other real-time data that makes a meeting interactive. This is where **NATS** comes in.\\n\\nMore specifically, we leverage **NATS JetStream**, the powerful persistence layer built into the NATS ecosystem. JetStream elevates NATS from a simple messaging system to a true streaming platform, which is critical for the reliability and scalability of our backend services.\\n\\nHere\u2019s why JetStream was the perfect choice for plugNmeet:\\n\\n*   **Multi-Layered Security:** NATS provides a robust, defense-in-depth security model at the messaging layer, which operates in addition to our application-level E2EE.\\n    *   **Encryption in Transit:** All connections from clients to the NATS cluster are secured using **TLS**. This encrypts all signaling data while it\'s on the wire, protecting it from eavesdropping.\\n    *   **Fine-Grained Authorization:** This is where the real power lies. When a user authenticates, the `plugnmeet-server` dynamically generates a unique set of permissions for that specific user session. These permissions strictly define which NATS subjects the user is allowed to publish to and subscribe from, typically scoped by `roomId` and `userId`. This enforces a true **principle of least privilege**, making it architecturally impossible for a user in one room to access data from another.\\n\\n*   **Scalable Request Processing with Queue Workers:** For critical client-server interactions, like fetching the initial user list, we leverage JetStream\'s powerful **queue worker pattern**. When a client sends a request, it\'s published to a stream. Our backend `plugnmeet-server` instances subscribe to this stream as a **queue group**, and NATS ensures that each request is delivered to only **one** available server. This provides automatic, built-in load balancing for our core application logic.\\n\\n*   **High-Performance Streaming for Real-Time Data:** For other real-time data like **chat messages** or **collaborative whiteboard** drawing data, we use JetStream\'s high-performance streaming capabilities to ensure fast and reliable delivery to all participants in a room.\\n\\n*   **Built for Resilience:** NATS is designed from the ground up for clustering and self-healing. If one NATS node fails, clients will automatically reconnect to another, ensuring the \\"nervous system\\" of your meetings stays online.\\n\\nBy using NATS for its deep security model, performance, and resilience, we built a backend that is fast, secure, and remarkably easy to scale.\\n\\n---\\n\\n## Conclusion: A Foundation Built for the Future\\n\\nThe choice of LiveKit and NATS JetStream was deliberate. By combining a best-in-class media server with a best-in-class streaming platform, we\'ve created a platform that is:\\n\\n*   **Performant:** Handling both media and signaling with specialized, high-speed tools.\\n*   **Scalable:** With clear, documented paths for clustering each component.\\n*   **Resilient:** With built-in failover and self-healing capabilities.\\n*   **Flexible:** Allowing us to build powerful, decoupled features like our auto-scaling recorders.\\n\\nBut there\'s one more crucial element that ties this all together: **the underlying technology**. Both LiveKit and NATS are written in **Go**, one of the most powerful languages for modern, concurrent network services. This was no accident. We deliberately chose to write the core `plugnmeet-server` in Go as well.\\n\\nThis creates a **unified, high-performance ecosystem**. Our developers can move seamlessly between components, leading to faster development cycles, easier maintenance, and a more cohesive and stable platform for our users. It means that when you build with plugNmeet, you\'re building on a consistent and coherent technology stack from top to bottom.\\n\\nThe ultimate benefit of this Go-based approach is in the final deployment. The entire `plugnmeet-server` compiles down to a **single, dependency-free binary file**. This makes deployment incredibly simple and portable. You can run it as a standalone service on a bare-metal server or package it into a minimal, highly secure Docker container. There are no language runtimes to manage and no complex dependencies to install\u2014just a single file that works.\\n\\nWhen you choose plugNmeet, you\'re not just getting an application. You\'re getting a thoughtfully designed architecture built on a foundation you can trust.\\n\\n---\\n**Want to learn more?**\\n\\n*   **Read our [Scalable Deployment Guide](/docs/developer-guide/scalable-setup)**\\n*   **Explore the [Open-Source Project on GitHub](https://github.com/mynaparrot/plugNmeet-server)**"},{"id":"build-video-conferencing-app-in-under-an-hour","metadata":{"permalink":"/blog/build-video-conferencing-app-in-under-an-hour","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-26-build-video-conferencing-app-in-under-an-hour.md","source":"@site/blog/2025-10-26-build-video-conferencing-app-in-under-an-hour.md","title":"How to Build Your Own Video Conferencing App in Under an Hour","description":"Building a video conferencing application sounds like a monumental task. You have to wrestle with the complexities of WebRTC, set up signaling servers, manage STUN/TURN for NAT traversal, and handle the resource-intensive job of routing media streams. The backend infrastructure alone can take months to build and stabilize.","date":"2025-10-26T00:00:00.000Z","tags":[{"inline":true,"label":"webrtc","permalink":"/blog/tags/webrtc"},{"inline":true,"label":"api","permalink":"/blog/tags/api"},{"inline":true,"label":"sdk","permalink":"/blog/tags/sdk"},{"inline":true,"label":"developer","permalink":"/blog/tags/developer"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"},{"inline":true,"label":"programming","permalink":"/blog/tags/programming"}],"readingTime":4.01,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"How to Build Your Own Video Conferencing App in Under an Hour","slug":"build-video-conferencing-app-in-under-an-hour","authors":["jibon"],"tags":["webrtc","api","sdk","developer","tutorial","programming"]},"unlisted":false,"prevItem":{"title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","permalink":"/blog/backend-architecture-deep-dive"}},"content":"Building a video conferencing application sounds like a monumental task. You have to wrestle with the complexities of WebRTC, set up signaling servers, manage STUN/TURN for NAT traversal, and handle the resource-intensive job of routing media streams. The backend infrastructure alone can take months to build and stabilize.\\n\\nBut what if you could skip all of that?\\n\\nWhat if you could leverage a powerful, open-source platform that handles all the backend complexity, allowing you to build a fully functional, custom-branded video conferencing app in under an hour? With **plugNmeet**, you can.\\n\\nThis guide will show you the three core steps to building your own video app using plugNmeet\'s API-first architecture.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\n## The Old Way: The Mountain of Complexity\\n\\nBefore we show you the easy way, it\'s important to appreciate the problems plugNmeet solves. Building a WebRTC app from scratch requires you to become an expert in:\\n\\n1.  **Signaling:** Creating a system (usually with WebSockets) to coordinate connections between users.\\n2.  **NAT Traversal:** Setting up and managing STUN/TURN servers to allow users behind firewalls to connect to each other.\\n3.  **Media Server (SFU):** Deploying and scaling a Selective Forwarding Unit (like LiveKit, Mediasoup, or Janus) to efficiently route video and audio streams.\\n4.  **Backend Logic:** Writing an application server to manage rooms, users, and permissions.\\n5.  **Frontend UI:** Building a complete user interface from scratch to handle video elements, buttons, chat, and more.\\n\\nThis is a massive undertaking.\\n\\n## The plugNmeet Way: An API-First Framework\\n\\nplugNmeet bundles all of this complexity into a single, open-source server that you can install with an automated script. It provides you with a simple, powerful set of APIs that act as your building blocks.\\n\\nHere\'s how you build your app in three steps.\\n\\n### Step 1: Set Up the Backend (5 Minutes)\\n\\nFirst, you need the plugNmeet server, which includes LiveKit for media and NATS for messaging. You can install everything on a fresh Ubuntu server using our automated installation script.\\n\\n```bash\\nwget https://raw.githubusercontent.com/mynaparrot/plugNmeet-install/main/install.sh\\nchmod +x install.sh\\n./install.sh\\n```\\n\\nThat\'s it. You now have a production-ready media server and API endpoint. The script will provide you with your `API_KEY` and `API_SECRET`, which you\'ll need for the next step.\\n\\n### Step 2: Control the Backend with an API Call (10 Minutes)\\n\\nNext, you need to tell your backend to create a meeting room and generate a token for a user to join. This is done with a simple server-side API call.\\n\\nYou can use our official PHP SDK or JavaScript SDK, or call the API directly. Here\u2019s a simple example in PHP:\\n\\n```php\\n<?php\\nrequire __DIR__ . \\"/plugNmeetConnect.php\\";\\n\\n$config = new stdClass();\\n$config->plugnmeet_server_url = \\"https://demo.plugnmeet.com\\"; // Your server URL\\n$config->plugnmeet_api_key = \\"plugnmeet\\"; // Your API Key\\n$config->plugnmeet_secret = \\"zumyyYWqv7KR2kUqvYdq4z4sXg7XTBD2ljT6\\"; // Your API Secret\\n\\n$connect = new plugNmeetConnect($config);\\n\\n$roomId = \\"room01\\"; // Must be unique. You can also use $connect->getUUID();\\n$user_full_name = \\"John Doe\\";\\n$userId = \\"your-unique-user-id\\"; // Must be unique for each user.\\n\\n// Define all the features for this specific room.\\n$roomMetadata = array(\\n    \\"room_features\\" => array(\\n        \\"allow_webcams\\" => true,\\n        \\"mute_on_start\\" => false,\\n        \\"allow_screen_share\\" => true,\\n        \\"room_duration\\" => 0 // 0 = no limit\\n    ),\\n    // ... and many more options\\n);\\n$create = $connect->createRoom($roomId, \\"Test room\\", \\"Welcome to room\\", 0, \\"\\", $roomMetadata);\\n// $create->getStatus();\\n\\n$join = $connect->getJoinToken($roomId, $user_full_name, $userId, true);\\n// $join->getStatus();\\n\\n$url = $config->plugnmeet_server_url . \\"?access_token=\\" . $join->getToken();\\necho $url;\\n```\\n\\nThis script creates a room and gives you a unique URL with a token that grants \\"John Doe\\" access to that room. You can find full example of PHP from [PHP Quick Start](/docs/tutorials/quick_php)\\n\\n### Step 3: Display the Frontend (2 Minutes)\\n\\nNow for the final piece: the user interface. Do you need to build one from scratch? No.\\n\\nplugNmeet provides a complete, feature-rich, and customizable web client. You simply need to direct your user to the join URL generated in the previous step.\\n\\nThe join URL looks something like this:\\n`https://your-domain.com/login.html?access_token=YOUR_GENERATED_TOKEN`\\n\\nWhen a user visits this link, the plugNmeet client application loads, authenticates them with the token, and places them directly into the video meeting.\\n\\n---\\n\\n## Conclusion: You\'re a Video App Developer Now\\n\\nIn the time it took to read this article, you\'ve learned the entire workflow:\\n\\n1.  **Install a powerful backend** with a single command.\\n2.  **Use a simple API call** to control rooms and users.\\n3.  **Use the pre-built client** to provide an instant user interface.\\n\\nYou\'ve skipped the mountain of WebRTC complexity and gone straight to building your application. From here, you can use our **Design Customization** features to completely white-label the client, or use our webhooks to build complex business logic around your meetings.\\n\\nThe power of a complete WebRTC platform is now at your fingertips. What will you build?\\n\\n---\\n**Ready to get started?**\\n\\n*   **Follow the [Installation Guide](/docs/installation)**\\n*   **Explore the [API Documentation](/docs/api/intro)**"}]}}')}}]);