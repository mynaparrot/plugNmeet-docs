"use strict";(self.webpackChunkplugnmeet_documentation=self.webpackChunkplugnmeet_documentation||[]).push([[2875],{6972:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});var t=n(8294),r=n(7259),s=n(4482);const a={title:"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture",slug:"backend-architecture-deep-dive",authors:["jibon"],tags:["webrtc","architecture","backend","livekit","nats","open-source","scalability"]},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The Two Pillars of Real-Time Communication",id:"the-two-pillars-of-real-time-communication",level:2},{value:"Pillar 1: LiveKit - The High-Performance Media Engine",id:"pillar-1-livekit---the-high-performance-media-engine",level:2},{value:"Pillar 2: NATS JetStream - The Resilient Nervous System",id:"pillar-2-nats-jetstream---the-resilient-nervous-system",level:2},{value:"Conclusion: A Foundation Built for the Future",id:"conclusion-a-foundation-built-for-the-future",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors."}),"\n",(0,r.jsxs)(i.p,{children:["When we designed plugNmeet, we had a clear set of goals: the platform needed to be high-performance, horizontally scalable, resilient, and easy for developers to build upon. This led us to make two fundamental decisions for our backend: we chose ",(0,r.jsx)(i.strong,{children:"LiveKit"})," for our media server and ",(0,r.jsx)(i.strong,{children:"NATS"})," for our real-time messaging layer."]}),"\n",(0,r.jsx)(i.p,{children:'This article is a deep dive into the "why" behind these critical choices.'}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"the-two-pillars-of-real-time-communication",children:"The Two Pillars of Real-Time Communication"}),"\n",(0,r.jsx)(i.p,{children:"At its core, any serious video conferencing platform has to solve two distinct problems. But for a project like plugNmeet, it's not enough to just make them work. The solution must also be:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Easy to Scale:"})," Able to grow from handling a few dozen users to many thousands without a complete re-architecture."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Highly Available:"})," Resilient to failure, ensuring that the loss of a single component doesn't bring the entire system down."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Resource-Efficient & Cost-Effective:"})," Designed to run on reasonable hardware, keeping operational costs low for everyone."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Easy to Manage:"})," Simple to deploy and maintain, even for small teams or individual developers."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["Our architectural philosophy was to choose a best-in-class open-source tool for each of the two main challenges\u2014",(0,r.jsx)(i.strong,{children:"Media Routing"})," and ",(0,r.jsx)(i.strong,{children:"Signaling"}),"\u2014that met all of these demanding criteria."]}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Media Routing:"})," How do you efficiently get audio and video streams from each participant to every other participant?"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Signaling & State Management:"})," How do you instantly deliver all the other real-time information that makes a meeting dynamic and interactive?"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"pillar-1-livekit---the-high-performance-media-engine",children:"Pillar 1: LiveKit - The High-Performance Media Engine"}),"\n",(0,r.jsx)(i.p,{children:"In the early days of WebRTC, many apps used a peer-to-peer (P2P) mesh. This works for a 1-on-1 call, but it fails catastrophically as you add more people. Each participant has to upload their video stream separately to every other person, quickly overwhelming their internet connection."}),"\n",(0,r.jsxs)(i.p,{children:["The modern solution is a ",(0,r.jsx)(i.strong,{children:"Selective Forwarding Unit (SFU)"}),". An SFU is a server that acts as a traffic cop. Each participant sends their video stream to the SFU just ",(0,r.jsx)(i.em,{children:"once"}),", and the SFU then forwards that stream to all other participants."]}),"\n",(0,r.jsxs)(i.p,{children:["For our SFU, we chose ",(0,r.jsx)(i.strong,{children:"LiveKit"}),", and here\u2019s why:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Performance & Efficiency:"})," LiveKit is written in Go, making it incredibly fast and resource-efficient. It can handle a large number of concurrent users and streams on a single server, which aligns with our goal of providing a cost-effective solution."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Built-in Scalability:"})," LiveKit is designed to be clustered, and it uses Redis to manage state across multiple nodes. This provides a clear, documented path to the massive scale required by our largest users."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Modern Features by Default:"})," LiveKit comes with critical, out-of-the-box support for modern WebRTC features like ",(0,r.jsx)(i.strong,{children:"Simulcast"})," (sending multiple quality streams) and ",(0,r.jsx)(i.strong,{children:"Dynacast"})," (intelligently pausing streams). This allows plugNmeet to automatically adapt to each user's network conditions, dramatically improving reliability."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Secure and Open Source:"})," As an open-source project itself, LiveKit aligns with our core philosophy of transparency. It also has built-in support for passing through End-to-End Encrypted (E2EE) media, which is essential for our security model."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"In short, by building on top of LiveKit, we didn't have to reinvent the wheel. We inherited a powerful, battle-tested media engine, allowing us to focus on building the application logic and features that make plugNmeet unique."}),"\n",(0,r.jsx)(i.h2,{id:"pillar-2-nats-jetstream---the-resilient-nervous-system",children:"Pillar 2: NATS JetStream - The Resilient Nervous System"}),"\n",(0,r.jsxs)(i.p,{children:["While LiveKit handles the heavy media streams, we needed a separate, highly reliable system for all the other real-time data that makes a meeting interactive. This is where ",(0,r.jsx)(i.strong,{children:"NATS"})," comes in."]}),"\n",(0,r.jsxs)(i.p,{children:["More specifically, we leverage ",(0,r.jsx)(i.strong,{children:"NATS JetStream"}),", the powerful persistence layer built into the NATS ecosystem. JetStream elevates NATS from a simple messaging system to a true streaming platform, which is critical for the reliability and scalability of our backend services."]}),"\n",(0,r.jsx)(i.p,{children:"Here\u2019s why JetStream was the perfect choice for plugNmeet:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Multi-Layered Security:"})," NATS provides a robust, defense-in-depth security model at the messaging layer, which operates in addition to our application-level E2EE."]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Encryption in Transit:"})," All connections from clients to the NATS cluster are secured using ",(0,r.jsx)(i.strong,{children:"TLS"}),". This encrypts all signaling data while it's on the wire, protecting it from eavesdropping."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Fine-Grained Authorization:"})," This is where the real power lies. When a user authenticates, the ",(0,r.jsx)(i.code,{children:"plugnmeet-server"})," dynamically generates a unique set of permissions for that specific user session. These permissions strictly define which NATS subjects the user is allowed to publish to and subscribe from, typically scoped by ",(0,r.jsx)(i.code,{children:"roomId"})," and ",(0,r.jsx)(i.code,{children:"userId"}),". This enforces a true ",(0,r.jsx)(i.strong,{children:"principle of least privilege"}),", making it architecturally impossible for a user in one room to access data from another."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Scalable Request Processing with Queue Workers:"})," For critical client-server interactions, like fetching the initial user list, we leverage JetStream's powerful ",(0,r.jsx)(i.strong,{children:"queue worker pattern"}),". When a client sends a request, it's published to a stream. Our backend ",(0,r.jsx)(i.code,{children:"plugnmeet-server"})," instances subscribe to this stream as a ",(0,r.jsx)(i.strong,{children:"queue group"}),", and NATS ensures that each request is delivered to only ",(0,r.jsx)(i.strong,{children:"one"})," available server. This provides automatic, built-in load balancing for our core application logic."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"High-Performance Streaming for Real-Time Data:"})," For other real-time data like ",(0,r.jsx)(i.strong,{children:"chat messages"})," or ",(0,r.jsx)(i.strong,{children:"collaborative whiteboard"})," drawing data, we use JetStream's high-performance streaming capabilities to ensure fast and reliable delivery to all participants in a room."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Built for Resilience:"}),' NATS is designed from the ground up for clustering and self-healing. If one NATS node fails, clients will automatically reconnect to another, ensuring the "nervous system" of your meetings stays online.']}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"By using NATS for its deep security model, performance, and resilience, we built a backend that is fast, secure, and remarkably easy to scale."}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"conclusion-a-foundation-built-for-the-future",children:"Conclusion: A Foundation Built for the Future"}),"\n",(0,r.jsx)(i.p,{children:"The choice of LiveKit and NATS JetStream was deliberate. By combining a best-in-class media server with a best-in-class streaming platform, we've created a platform that is:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Performant:"})," Handling both media and signaling with specialized, high-speed tools."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Scalable:"})," With clear, documented paths for clustering each component."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Resilient:"})," With built-in failover and self-healing capabilities."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Flexible:"})," Allowing us to build powerful, decoupled features like our auto-scaling recorders."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["But there's one more crucial element that ties this all together: ",(0,r.jsx)(i.strong,{children:"the underlying technology"}),". Both LiveKit and NATS are written in ",(0,r.jsx)(i.strong,{children:"Go"}),", one of the most powerful languages for modern, concurrent network services. This was no accident. We deliberately chose to write the core ",(0,r.jsx)(i.code,{children:"plugnmeet-server"})," in Go as well."]}),"\n",(0,r.jsxs)(i.p,{children:["This creates a ",(0,r.jsx)(i.strong,{children:"unified, high-performance ecosystem"}),". Our developers can move seamlessly between components, leading to faster development cycles, easier maintenance, and a more cohesive and stable platform for our users. It means that when you build with plugNmeet, you're building on a consistent and coherent technology stack from top to bottom."]}),"\n",(0,r.jsxs)(i.p,{children:["The ultimate benefit of this Go-based approach is in the final deployment. The entire ",(0,r.jsx)(i.code,{children:"plugnmeet-server"})," compiles down to a ",(0,r.jsx)(i.strong,{children:"single, dependency-free binary file"}),". This makes deployment incredibly simple and portable. You can run it as a standalone service on a bare-metal server or package it into a minimal, highly secure Docker container. There are no language runtimes to manage and no complex dependencies to install\u2014just a single file that works."]}),"\n",(0,r.jsx)(i.p,{children:"When you choose plugNmeet, you're not just getting an application. You're getting a thoughtfully designed architecture built on a foundation you can trust."}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Want to learn more?"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsxs)(i.strong,{children:["Read our ",(0,r.jsx)(i.a,{href:"/docs/developer-guide/scalable-setup",children:"Scalable Deployment Guide"})]})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsxs)(i.strong,{children:["Explore the ",(0,r.jsx)(i.a,{href:"https://github.com/mynaparrot/plugNmeet-server",children:"Open-Source Project on GitHub"})]})}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},4482:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var t=n(6363);const r={},s=t.createContext(r);function a(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:i},e.children)}},8294:e=>{e.exports=JSON.parse('{"permalink":"/blog/backend-architecture-deep-dive","editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/blog/2025-10-27-backend-architecture-deep-dive.md","source":"@site/blog/2025-10-27-backend-architecture-deep-dive.md","title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","description":"Every great application is built on a foundation of smart architectural choices. For a real-time video conferencing platform, these choices are the difference between a smooth, reliable experience and a frustrating mess of lag, dropped calls, and connection errors.","date":"2025-10-27T00:00:00.000Z","tags":[{"inline":true,"label":"webrtc","permalink":"/blog/tags/webrtc"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"},{"inline":true,"label":"backend","permalink":"/blog/tags/backend"},{"inline":true,"label":"livekit","permalink":"/blog/tags/livekit"},{"inline":true,"label":"nats","permalink":"/blog/tags/nats"},{"inline":true,"label":"open-source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"scalability","permalink":"/blog/tags/scalability"}],"readingTime":6.44,"hasTruncateMarker":true,"authors":[{"name":"Jibon L. Costa","title":"Founding developer","url":"https://github.com/jibon57","imageURL":"https://github.com/jibon57.png","key":"jibon","page":null}],"frontMatter":{"title":"Why We Chose LiveKit and NATS: A Deep Dive into Our Backend Architecture","slug":"backend-architecture-deep-dive","authors":["jibon"],"tags":["webrtc","architecture","backend","livekit","nats","open-source","scalability"]},"unlisted":false,"prevItem":{"title":"Meet Users Where They Are: Why We Build Plugins, Not Another Standalone App","permalink":"/blog/plugin-first-philosophy"},"nextItem":{"title":"How to Build Your Own Video Conferencing App in Under an Hour","permalink":"/blog/build-video-conferencing-app-in-under-an-hour"}}')}}]);