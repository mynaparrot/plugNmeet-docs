"use strict";(self.webpackChunkplugnmeet_documentation=self.webpackChunkplugnmeet_documentation||[]).push([[579],{9610:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"security-overview","title":"Plug-N-Meet Security Overview | Your Self-Hosted Video Conferencing Solution","description":"A detailed overview of the security architecture, authentication, authorization, and end-to-end encryption (E2EE) mechanisms within the Plug-N-Meet platform.","source":"@site/docs/security-overview.md","sourceDirName":".","slug":"/security-overview","permalink":"/docs/security-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/docs/security-overview.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Plug-N-Meet Security Overview | Your Self-Hosted Video Conferencing Solution","description":"A detailed overview of the security architecture, authentication, authorization, and end-to-end encryption (E2EE) mechanisms within the Plug-N-Meet platform.","keywords":["security","e2ee","end-to-end encryption","authentication","authorization","hmac","jwt","nats","livekit","webrtc security"],"sidebar_position":3,"sidebar_label":"Security Overview"},"sidebar":"tutorialSidebar","previous":{"title":"Installation Guide","permalink":"/docs/installation"},"next":{"title":"Overview","permalink":"/docs/user-guide/overview"}}');var t=i(7259),r=i(4482);const a={title:"Plug-N-Meet Security Overview | Your Self-Hosted Video Conferencing Solution",description:"A detailed overview of the security architecture, authentication, authorization, and end-to-end encryption (E2EE) mechanisms within the Plug-N-Meet platform.",keywords:["security","e2ee","end-to-end encryption","authentication","authorization","hmac","jwt","nats","livekit","webrtc security"],sidebar_position:3,sidebar_label:"Security Overview"},o="Plug-N-Meet Security Overview",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"1. API Authentication",id:"1-api-authentication",level:3},{value:"2. User Authentication &amp; Authorization",id:"2-user-authentication--authorization",level:3},{value:"3. End-to-End Encryption (E2EE)",id:"3-end-to-end-encryption-e2ee",level:3},{value:"3.1. Server-Generated Keys",id:"31-server-generated-keys",level:4},{value:"3.2. User-Provided Keys",id:"32-user-provided-keys",level:4},{value:"4. Transport &amp; Data-in-Transit Security",id:"4-transport--data-in-transit-security",level:3},{value:"4.1. NATS Communication",id:"41-nats-communication",level:4},{value:"4.2. Media Server (LiveKit)",id:"42-media-server-livekit",level:4},{value:"5. Secure Session Flow",id:"5-secure-session-flow",level:3},{value:"6. Browser Storage (IndexedDB)",id:"6-browser-storage-indexeddb",level:3},{value:"Data Lifecycle and Encryption",id:"data-lifecycle-and-encryption",level:4},{value:"7. Server-Side Data Handling &amp; Persistence",id:"7-server-side-data-handling--persistence",level:3},{value:"7.1. Real-Time Session State (Redis or NATS KV)",id:"71-real-time-session-state-redis-or-nats-kv",level:4},{value:"7.2. Persistent Database (MariaDB)",id:"72-persistent-database-mariadb",level:4},{value:"7.3. Optional Analytics Data",id:"73-optional-analytics-data",level:4},{value:"7.4. Cloud Recordings",id:"74-cloud-recordings",level:4}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"plug-n-meet-security-overview",children:"Plug-N-Meet Security Overview"})}),"\n",(0,t.jsx)(n.p,{children:"This document provides an overview of the security architecture and mechanisms implemented within the Plug-N-Meet a platform. Our goal is to ensure the confidentiality, integrity, and availability of all communications."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#1-api-authentication",children:"API Authentication"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#2-user-authentication--authorization",children:"User Authentication & Authorization"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#3-end-to-end-encryption-e2ee",children:"End-to-End Encryption (E2EE)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#31-server-generated-keys",children:"Server-Generated Keys"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#32-user-provided-keys",children:"User-Provided Keys"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#4-transport--data-in-transit-security",children:"Transport & Data-in-Transit Security"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#41-nats-communication",children:"NATS Communication"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#42-media-server-livekit",children:"Media Server (LiveKit)"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#5-secure-session-flow",children:"Secure Session Flow"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#6-browser-storage-indexeddb",children:"Browser Storage (IndexedDB)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#7-server-side-data-handling--persistence",children:"Server-Side Data Handling & Persistence"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"1-api-authentication",children:"1. API Authentication"}),"\n",(0,t.jsxs)(n.p,{children:["All server-to-server API requests, such as creating a room or generating a join token, must be authenticated to prevent unauthorized access. This is achieved through a robust HMAC-based signature verification process. For detailed information on the API endpoints and their parameters, please refer to the ",(0,t.jsx)(n.a,{href:"/docs/api/intro",children:"API Documentation"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API Key"}),": Every request must include a valid ",(0,t.jsx)(n.code,{children:"API-KEY"})," in its headers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"HMAC Signature"}),": A ",(0,t.jsx)(n.code,{children:"HASH-SIGNATURE"})," header must be provided, which is a ",(0,t.jsx)(n.strong,{children:"HMAC-SHA256"})," hash of the request payload, signed with the shared ",(0,t.jsx)(n.code,{children:"API-SECRET"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The server validates the API key and re-computes the hash on its end. It performs a constant-time comparison against the provided signature to mitigate timing attacks. Any request with an invalid key or signature is immediately rejected."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Reference: ",(0,t.jsx)(n.code,{children:"server/pkg/controllers/auth.go"})," (",(0,t.jsx)(n.code,{children:"HandleAuthHeaderCheck"}),")"]})}),"\n",(0,t.jsx)(n.h3,{id:"2-user-authentication--authorization",children:"2. User Authentication & Authorization"}),"\n",(0,t.jsx)(n.p,{children:"Before a user can connect to a room's real-time infrastructure (NATS and LiveKit), their access token must be verified."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The client sends its access token to the ",(0,t.jsx)(n.code,{children:"/api/verifyToken"})," endpoint."]}),"\n",(0,t.jsx)(n.li,{children:"The backend server validates the JWT, checks for duplicate connections, verifies the user is not on a blocklist, and ensures the room has not exceeded its participant limit."}),"\n",(0,t.jsx)(n.li,{children:"Upon successful verification, the server returns the necessary connection details, including NATS WebSocket URLs and a list of NATS subjects the user is permitted to interact with."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["All subsequent API calls from the client to the backend during the session require the ",(0,t.jsx)(n.code,{children:"Authorization"})," header with the user's access token."]}),"\n",(0,t.jsx)(n.p,{children:"To maintain a secure and uninterrupted session, the client application is responsible for proactively renewing the access token before it expires. This renewal process occurs securely over NATS: the client sends a renewal request via NATS, and the server responds with a new, updated token through the same secure NATS channel."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["References: ",(0,t.jsx)(n.code,{children:"server/pkg/controllers/auth.go"})," (",(0,t.jsx)(n.code,{children:"HandleVerifyToken"}),"), ",(0,t.jsx)(n.code,{children:"client/src/helpers/api/plugNmeetAPI.ts"})]})}),"\n",(0,t.jsx)(n.h3,{id:"3-end-to-end-encryption-e2ee",children:"3. End-to-End Encryption (E2EE)"}),"\n",(0,t.jsx)(n.p,{children:"Plug-N-Meet provides robust End-to-End Encryption (E2EE) for all peer-to-peer data, including media streams (audio, video, screen sharing), chat messages, whiteboard data and all notifications. This ensures that the server never has access to the unencrypted content."}),"\n",(0,t.jsx)(n.h4,{id:"31-server-generated-keys",children:"3.1. Server-Generated Keys"}),"\n",(0,t.jsxs)(n.p,{children:["When a room is created with E2EE enabled but ",(0,t.jsx)(n.code,{children:"enabled_self_insert_encryption_key"})," is ",(0,t.jsx)(n.code,{children:"false"}),", the backend server securely generates a 32-byte random string to serve as the base secret. This secret is stored as part of the room's metadata and distributed to authenticated participants when they join."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Upon receiving this secret, the client-side application does ",(0,t.jsx)(n.strong,{children:"not"})," use it directly for encryption."]}),"\n",(0,t.jsxs)(n.li,{children:["Instead, it processes the secret through the ",(0,t.jsx)(n.strong,{children:"PBKDF2 (Password-Based Key Derivation Function 2)"})," algorithm, using a static salt and 100,000 iterations."]}),"\n",(0,t.jsx)(n.li,{children:"This derives a strong AES-256 key that is used for all subsequent encryption and decryption operations."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["References: ",(0,t.jsx)(n.code,{children:"protocol/utils/create_room.go"})," (",(0,t.jsx)(n.code,{children:"SetCreateRoomDefaultValues"}),"), ",(0,t.jsx)(n.code,{children:"protocol/proto_files/plugnmeet_create_room.proto"})]})}),"\n",(0,t.jsx)(n.h4,{id:"32-user-provided-keys",children:"3.2. User-Provided Keys"}),"\n",(0,t.jsxs)(n.p,{children:["For maximum security and zero-trust, rooms can be configured with ",(0,t.jsx)(n.code,{children:"enabled_self_insert_encryption_key"})," set to ",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In this mode, each user is prompted to enter a secret key or passphrase upon joining. It is the participants' responsibility to coordinate and share the same secret key, as the server does not validate it. If participants use different keys, they will not be able to communicate with each other in the encrypted session."}),"\n",(0,t.jsxs)(n.li,{children:["The client-side application processes this passphrase through the same robust ",(0,t.jsx)(n.strong,{children:"PBKDF2"})," algorithm, using a static salt and 100,000 iterations. This process is intentionally slow to make brute-force attacks against the user's passphrase infeasible."]}),"\n",(0,t.jsx)(n.li,{children:"The strong cryptographic key derived from this process is then used for all encryption and decryption, ensuring the user's original secret is never used directly and is well-protected against attacks."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["References: ",(0,t.jsx)(n.code,{children:"client/src/components/extra-pages/InsertE2EEKey.tsx"}),", ",(0,t.jsx)(n.code,{children:"client/src/helpers/libs/cryptoMessages.ts"})," (",(0,t.jsx)(n.code,{children:"importSecretKeyFromPlainText"}),"), ",(0,t.jsx)(n.code,{children:"client/src/helpers/nats/ConnectNats.ts"})," (",(0,t.jsx)(n.code,{children:"createMediaServerConn"}),")"]})}),"\n",(0,t.jsx)(n.h3,{id:"4-transport--data-in-transit-security",children:"4. Transport & Data-in-Transit Security"}),"\n",(0,t.jsx)(n.h4,{id:"41-nats-communication",children:"4.1. NATS Communication"}),"\n",(0,t.jsx)(n.p,{children:"Communication for signaling, chat, and other data messages is handled via NATS."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Permissions"}),": When a user connects to NATS, the ",(0,t.jsx)(n.code,{children:"nats-auth-controller"})," on the backend dynamically generates a set of permissions based on the user's validated token. This strictly limits which subjects a user can publish or subscribe to, enforcing a principle of the least privilege."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"E2EE"}),": If E2EE is enabled for the room, all data payloads (e.g., chat messages, whiteboard updates) are encrypted on the client side ",(0,t.jsx)(n.em,{children:"before"})," being published to NATS. The server only routes the encrypted blobs of data."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["References: ",(0,t.jsx)(n.code,{children:"server/pkg/controllers/nats_auth_controller.go"}),", ",(0,t.jsx)(n.code,{children:"client/src/helpers/nats/ConnectNats.ts"})]})}),"\n",(0,t.jsx)(n.h4,{id:"42-media-server-livekit",children:"4.2. Media Server (LiveKit)"}),"\n",(0,t.jsx)(n.p,{children:"Media streams are managed by LiveKit, which has built-in support for E2EE."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The same cryptographic key used for NATS data is passed to the LiveKit SDK."}),"\n",(0,t.jsx)(n.li,{children:"The LiveKit client SDK handles the encryption and decryption of all audio, webcam, and screen-sharing tracks directly on the user's device. The media server (SFU) only relays encrypted media packets."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Reference: ",(0,t.jsx)(n.code,{children:"client/src/helpers/livekit/ConnectLivekit.ts"})]})}),"\n",(0,t.jsx)(n.h3,{id:"5-secure-session-flow",children:"5. Secure Session Flow"}),"\n",(0,t.jsx)(n.p,{children:"The end-to-end connection process is designed with security at each step:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Token Verification"}),": Client verifies its token with the backend."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"E2EE Key Prompt (if applicable)"}),": If self-insertion is enabled, the user provides their secret key, which is hashed client-side."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NATS Connection"}),": The client connects to NATS using the credentials from step 1. The NATS auth service grants fine-grained permissions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initial Data Fetch"}),": The client requests initial room data over the secure NATS connection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"E2EE Key Import"}),": The client imports the E2EE key (either from the server or derived from user input)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Media Connection"}),": The client connects to the LiveKit media server, enabling E2EE with the imported key."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encrypted Communication"}),": All subsequent data and media are now end-to-end encrypted."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"6-browser-storage-indexeddb",children:"6. Browser Storage (IndexedDB)"}),"\n",(0,t.jsx)(n.p,{children:"To enhance user experience and ensure session continuity, the application utilizes the browser's built-in IndexedDB storage. This is used for purely functional purposes, such as restoring a user's session if they accidentally refresh their page."}),"\n",(0,t.jsx)(n.p,{children:"To achieve this, the application temporarily stores ephemeral session data on the end-user's local device. The categories of data stored may include, but are not limited to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User & Session Preferences:"})," To remember settings like a chosen subtitle language."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session Content & History:"})," To restore chat messages, speech-to-text transcripts, and the state of the whiteboard."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Caches:"})," Such as cached images to improve loading times."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"data-lifecycle-and-encryption",children:"Data Lifecycle and Encryption"}),"\n",(0,t.jsx)(n.p,{children:"The data stored in IndexedDB is designed to be ephemeral and is handled as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encryption:"})," The data stored in IndexedDB is ",(0,t.jsx)(n.strong,{children:"not encrypted"})," by the application. This is a deliberate design choice, as the data resides on the end-user's own device and is protected by the security measures of the user's operating system and browser profile. The primary security focus is on encrypting data ",(0,t.jsx)(n.em,{children:"in transit"})," and ensuring it is not persisted on any server."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Normal Session End:"}),' When a user properly ends their session (e.g., by clicking "End meeting" or "Leave Meeting"), all stored data for that session is ',(0,t.jsx)(n.strong,{children:"immediately and permanently deleted"})," from the browser."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Abnormal Session End (e.g., closing the browser tab):"})," If a session is not ended properly, the data remains in the browser's IndexedDB. However, upon the next application startup, a cleanup process runs. This process automatically identifies and deletes any stored data from previous sessions that has exceeded a predefined maximum age (e.g., several hours). This maximum age is configurable and subject to change in future versions to optimize performance and privacy."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This data is stored ",(0,t.jsx)(n.strong,{children:"only on the end-user's browser"})," and is never transmitted elsewhere for storage purposes."]}),"\n",(0,t.jsx)(n.li,{children:"The storage is essential for the application's expected functionality and is not used for tracking or analytics."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disclaimer for Operators:"})," As the person or organization deploying this software, you are responsible for creating and maintaining your own Privacy Policy. You should use this information to ensure your policy is transparent and compliant with any applicable data protection regulations (e.g., GDPR, CCPA)."]}),"\n",(0,t.jsx)(n.h3,{id:"7-server-side-data-handling--persistence",children:"7. Server-Side Data Handling & Persistence"}),"\n",(0,t.jsx)(n.p,{children:"To provide a complete picture of the data lifecycle, this section outlines how data is handled and stored on the server side. The architecture is designed to separate volatile real-time data from long-term persistent data, with a strong emphasis on user-controlled data retention."}),"\n",(0,t.jsx)(n.h4,{id:"71-real-time-session-state-redis-or-nats-kv",children:"7.1. Real-Time Session State (Redis or NATS KV)"}),"\n",(0,t.jsx)(n.p,{children:"During an active meeting, the server needs to manage the real-time state of the room, such as the list of participants, their mute status, and other immediate metadata. This is handled by a high-performance, in-memory key-value store (either Redis or NATS KV)."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Fast, real-time coordination of an active session."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lifecycle:"})," This data is volatile and is tied to the life of the session. It is automatically cleared when the session ends."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"72-persistent-database-mariadb",children:"7.2. Persistent Database (MariaDB)"}),"\n",(0,t.jsx)(n.p,{children:"For historical reference and administrative purposes, a small subset of non-sensitive information is stored in a persistent relational database (MariaDB)."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Long-term record-keeping of meeting occurrences."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Stored:"})," This typically includes basic room information such as ",(0,t.jsx)(n.code,{children:"roomId"}),", ",(0,t.jsx)(n.code,{children:"title"}),", creation/end time etc."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"73-optional-analytics-data",children:"7.3. Optional Analytics Data"}),"\n",(0,t.jsx)(n.p,{children:"PlugNmeet provides the option to persist detailed analytics for a session to help administrators understand usage patterns. This feature is governed by a setting that provides administrators with control over data retention."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Control:"})," The decision to ",(0,t.jsx)(n.strong,{children:"persist"})," analytics data is made by the administrator on a per-room basis via the ",(0,t.jsx)(n.code,{children:"enable_analytics"})," flag, adhering to the principle of privacy by default."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Collected:"})," The data aggregated in-memory during a session may include metrics such as user join/leave times, the number of times a user speaks, files uploaded, and other engagement events."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Storage:"})," If persisted, the aggregated analytics data is ",(0,t.jsx)(n.strong,{children:"always stored as a JSON file"})," on the server's filesystem. A reference to the filename and its associated room is then stored in a dedicated table in the persistent database for easy retrieval."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lifecycle:"})," Analytics data is aggregated in-memory during the course of an active session. Upon the conclusion of the session, the system checks the room's ",(0,t.jsx)(n.code,{children:"enable_analytics"})," setting.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"true"}),", the aggregated data is written to a JSON file, and its reference is saved to the database."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"false"}),", the in-memory data is immediately discarded and is not persisted in any form."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"74-cloud-recordings",children:"7.4. Cloud Recordings"}),"\n",(0,t.jsx)(n.p,{children:"When cloud recording is enabled for a session, the resulting media file (MP4) is stored on the server."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," To provide a persistent, shareable record of a meeting."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Storage:"})," The MP4 files are stored in a configurable directory on the server's filesystem."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Control & Lifecycle:"})," The management of these recordings is entirely controlled by the administrator via the API. Recordings are retained on the server indefinitely until they are explicitly deleted using the ",(0,t.jsx)(n.code,{children:"/recording/delete"})," API call. This gives the administrator full control over the data retention lifecycle."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"E2EE Incompatibility:"})," Server-side recording is ",(0,t.jsx)(n.strong,{children:"fundamentally incompatible"})," with zero-trust End-to-End Encryption. Therefore, cloud recording is automatically disabled and cannot be initiated if the room is configured with ",(0,t.jsx)(n.code,{children:"enabled_self_insert_encryption_key: true"}),". This is because the server has no access to the unencrypted media streams required to create the recording, which is the core guarantee of the E2EE model."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This layered approach to data handling ensures that plugNmeet is both performant and flexible, while giving operators the transparency and control needed to meet their own privacy and compliance obligations."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"This multi-layered approach ensures that Plug-N-Meet sessions are secure, private, and resilient against common threats."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},4482:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6363);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);