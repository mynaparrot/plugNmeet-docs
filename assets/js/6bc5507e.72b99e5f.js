"use strict";(self.webpackChunkplugnmeet_documentation=self.webpackChunkplugnmeet_documentation||[]).push([[8564],{6096:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"developer-guide/scalable-setup","title":"Scalable PlugNmeet Deployment | A Guide to Distributed Setups","description":"A high-level guide for scaling a self-hosted plugNmeet deployment. Learn how to create a distributed, multi-server architecture with clustered LiveKit, NATS, and more for high availability.","source":"@site/docs/developer-guide/scalable-setup.md","sourceDirName":"developer-guide","slug":"/developer-guide/scalable-setup","permalink":"/docs/developer-guide/scalable-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/mynaparrot/plugNmeet-docs/edit/main/docs/developer-guide/scalable-setup.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Scalable PlugNmeet Deployment | A Guide to Distributed Setups","description":"A high-level guide for scaling a self-hosted plugNmeet deployment. Learn how to create a distributed, multi-server architecture with clustered LiveKit, NATS, and more for high availability.","keywords":["scalable webrtc","distributed setup","plugnmeet scaling","high availability","load balancing","livekit cluster","nats cluster","redis cluster","self-hosted scaling","enterprise webrtc"],"sidebar_position":4,"sidebar_label":"Scalable Deployment"},"sidebar":"tutorialSidebar","previous":{"title":"Design Customization","permalink":"/docs/developer-guide/design-customisation"},"next":{"title":"PHP Quick Start","permalink":"/docs/tutorials/quick_php"}}');var r=i(7259),t=i(4482);const l={title:"Scalable PlugNmeet Deployment | A Guide to Distributed Setups",description:"A high-level guide for scaling a self-hosted plugNmeet deployment. Learn how to create a distributed, multi-server architecture with clustered LiveKit, NATS, and more for high availability.",keywords:["scalable webrtc","distributed setup","plugnmeet scaling","high availability","load balancing","livekit cluster","nats cluster","redis cluster","self-hosted scaling","enterprise webrtc"],sidebar_position:4,sidebar_label:"Scalable Deployment"},a="Scaling Your PlugNmeet Deployment",o={},c=[{value:"Before You Begin: A Phased Approach to Scaling",id:"before-you-begin-a-phased-approach-to-scaling",level:3},{value:"Phase 1: Isolate the Recorder (The Most Common Bottleneck)",id:"phase-1-isolate-the-recorder-the-most-common-bottleneck",level:4},{value:"Phase 2: Vertically Scale Your Main Server",id:"phase-2-vertically-scale-your-main-server",level:4},{value:"Phase 3: Go Fully Distributed",id:"phase-3-go-fully-distributed",level:4},{value:"Conceptual Architecture",id:"conceptual-architecture",level:2},{value:"Component Scaling Strategy",id:"component-scaling-strategy",level:2},{value:"1. Stateless Application &amp; Media Layers",id:"1-stateless-application--media-layers",level:3},{value:"The plugNmeet Server",id:"the-plugnmeet-server",level:4},{value:"LiveKit Media Server",id:"livekit-media-server",level:4},{value:"2. Stateful &amp; Clustered Infrastructure Layers",id:"2-stateful--clustered-infrastructure-layers",level:3},{value:"NATS Messaging System",id:"nats-messaging-system",level:4},{value:"MariaDB Database",id:"mariadb-database",level:4},{value:"Redis Cache",id:"redis-cache",level:4},{value:"3. The plugNmeet Recorder",id:"3-the-plugnmeet-recorder",level:3},{value:"Configuration",id:"configuration",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"scaling-your-plugnmeet-deployment",children:"Scaling Your PlugNmeet Deployment"})}),"\n",(0,r.jsx)(n.p,{children:"This guide provides a high-level overview and recommended strategies for scaling a self-hosted plugNmeet deployment to support a large number of concurrent users across multiple servers."}),"\n",(0,r.jsx)(n.h3,{id:"before-you-begin-a-phased-approach-to-scaling",children:"Before You Begin: A Phased Approach to Scaling"}),"\n",(0,r.jsx)(n.p,{children:"It is critical to understand that a fully distributed, multi-server setup is the most advanced and complex configuration. For many users, simpler scaling strategies can provide the necessary performance boost without the added complexity."}),"\n",(0,r.jsx)(n.p,{children:"We recommend approaching scaling in phases:"}),"\n",(0,r.jsx)(n.h4,{id:"phase-1-isolate-the-recorder-the-most-common-bottleneck",children:"Phase 1: Isolate the Recorder (The Most Common Bottleneck)"}),"\n",(0,r.jsxs)(n.p,{children:["For optimal performance, especially when recording frequently, we strongly recommend deploying the ",(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"plugnmeet-recorder"})," on a dedicated server"]}),", separate from your main ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," and LiveKit instance."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Why?"})," Recording and post-processing (transcoding) are CPU-intensive tasks. Isolating them prevents recording jobs from impacting the performance of your live meetings."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"When?"})," This should be your first step if you notice performance degradation during active recordings."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"However, if you only plan to record sessions infrequently, running the recorder on the same server (as the default installation script does) is a perfectly viable option."}),"\n",(0,r.jsx)(n.h4,{id:"phase-2-vertically-scale-your-main-server",children:"Phase 2: Vertically Scale Your Main Server"}),"\n",(0,r.jsxs)(n.p,{children:["If you are not recording heavily but are still seeing performance issues, the next step is to ",(0,r.jsx)(n.strong,{children:"vertically scale"})," your single server. This simply means adding more CPU cores and RAM. A single, well-provisioned server can comfortably handle ",(0,r.jsx)(n.strong,{children:"hundreds of concurrent users"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"phase-3-go-fully-distributed",children:"Phase 3: Go Fully Distributed"}),"\n",(0,r.jsx)(n.p,{children:"Only after you have isolated the recorder and vertically scaled your main server should you consider the fully distributed setup described in the rest of this guide. This advanced architecture is intended for very large-scale deployments where a single server is no longer sufficient."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"conceptual-architecture",children:"Conceptual Architecture"}),"\n",(0,r.jsx)(n.p,{children:"In a distributed setup, the core components of plugNmeet are separated onto different machines. A typical large-scale architecture consists of:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stateless Application & Media Layers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Multiple ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," instances."]}),"\n",(0,r.jsxs)(n.li,{children:["Multiple ",(0,r.jsx)(n.code,{children:"LiveKit"})," media server instances."]}),"\n",(0,r.jsx)(n.li,{children:"A standard Load Balancer."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stateful & Clustered Infrastructure Layers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"NATS"})," cluster."]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"Redis"})," cluster."]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"MariaDB"})," cluster."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Horizontally Scaled Recorders:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Multiple ",(0,r.jsx)(n.code,{children:"plugnmeet-recorder"})," instances, potentially in different operational modes."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"component-scaling-strategy",children:"Component Scaling Strategy"}),"\n",(0,r.jsx)(n.p,{children:"The key to a successful distributed setup is understanding how each component scales. The components fall into two main categories: stateless services that can be easily load-balanced, and stateful services that require their own specific clustering configurations."}),"\n",(0,r.jsx)(n.h3,{id:"1-stateless-application--media-layers",children:"1. Stateless Application & Media Layers"}),"\n",(0,r.jsx)(n.p,{children:"These components can be placed behind a standard load balancer, whose primary role is to terminate SSL and distribute initial traffic."}),"\n",(0,r.jsx)(n.h4,{id:"the-plugnmeet-server",children:"The plugNmeet Server"}),"\n",(0,r.jsxs)(n.p,{children:["The main ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," application is ",(0,r.jsx)(n.strong,{children:"stateless"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action:"})," You can run multiple instances on different machines and place them behind a standard L4 or L7 load balancer using a simple algorithm like round-robin or least connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration:"})," Each instance must be configured to point to the same shared infrastructure (NATS, Redis, and MariaDB)."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"livekit-media-server",children:"LiveKit Media Server"}),"\n",(0,r.jsx)(n.p,{children:"LiveKit also works behind a load balancer for initial connections."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action:"})," The load balancer can terminate SSL and proxy the initial connection to any available LiveKit node."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Critical Note:"})," Once the connection is established, LiveKit's own internal clustering logic handles all complex media routing. It is ",(0,r.jsx)(n.strong,{children:"essential to follow the official LiveKit documentation for clustering"})," to configure the backend correctly."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Firewall Configuration:"})," Ensure that your firewall rules allow the necessary TCP and UDP ports for WebRTC traffic to reach your LiveKit instances. For a detailed list of required ports, please refer to our ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/firewall",children:"Firewall Configuration Guide"})}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dependency:"})," A standalone or clustered Redis instance is required for LiveKit clustering."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["**(Link: ",(0,r.jsx)(n.a,{href:"https://docs.livekit.io/home/self-hosting/distributed",children:"Official LiveKit Clustering Guide"}),")"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-stateful--clustered-infrastructure-layers",children:"2. Stateful & Clustered Infrastructure Layers"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Critical Warning:"})," The following components have their own robust clustering and service discovery mechanisms. Placing them behind a standard, simple TCP/L4 load balancer without specific, advanced configuration is ",(0,r.jsx)(n.strong,{children:"highly likely to cause system instability, data corruption, or complete failure."})," Always follow the official clustering documentation for these services."]}),"\n",(0,r.jsx)(n.h4,{id:"nats-messaging-system",children:"NATS Messaging System"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recommendation:"})," NATS has its own clustering and client routing capabilities. Your ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," and ",(0,r.jsx)(n.code,{children:"plugnmeet-recorder"})," clients should be configured with a list of all NATS nodes in the cluster. The clients will automatically handle failover."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action:"})," Follow the ",(0,r.jsx)(n.strong,{children:"official NATS documentation for creating a cluster"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["**(Link: ",(0,r.jsx)(n.a,{href:"https://docs.nats.io/running-a-nats-service/configuration/clustering/jetstream_clustering",children:"Official NATS Clustering Documentation"}),")"]}),"\n",(0,r.jsx)(n.h4,{id:"mariadb-database",children:"MariaDB Database"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recommendation:"})," For high availability, the database must be clustered. All ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," instances must point to the same database cluster."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action:"})," Use a managed, high-availability database service from a cloud provider, or set up your own solution like a MariaDB Galera Cluster. Follow the official documentation for your chosen solution."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["**(Link: ",(0,r.jsx)(n.a,{href:"https://mariadb.com/docs/server/ha-and-performance/standard-replication/setting-up-replication",children:"Official MariaDB Documentation"}),")"]}),"\n",(0,r.jsx)(n.h4,{id:"redis-cache",children:"Redis Cache"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recommendation:"})," For a highly available LiveKit cluster, your Redis instance must also be highly available."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action:"})," Use a managed Redis service or set up your own Redis Cluster or Sentinel configuration. Your LiveKit nodes should be configured to connect to this cluster directly."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["**(Link: ",(0,r.jsx)(n.a,{href:"https://redis.io/docs/latest/operate/oss_and_stack/management/sentinel",children:"Official Redis Sentinel Clustering Documentation"}),")"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-the-plugnmeet-recorder",children:"3. The plugNmeet Recorder"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"plugnmeet-recorder"})," is a special case. While it is stateful during a job, its discovery and load balancing are handled automatically."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Load Balancing & Discovery:"})," The recorder does ",(0,r.jsx)(n.strong,{children:"not"})," require an external load balancer. Recorders automatically announce their availability over NATS, and the ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," distributes jobs to them."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Operational Modes:"})," The ",(0,r.jsx)(n.code,{children:"plugnmeet-recorder"})," supports different operational modes, allowing for a highly scalable and resilient pipeline. Each instance can be configured via the ",(0,r.jsx)(n.code,{children:"mode"})," setting in ",(0,r.jsx)(n.code,{children:"config.yaml"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"recorderOnly"}),":"]})," This instance will ",(0,r.jsx)(n.em,{children:"only"})," handle live session recording. Once a raw recording file is captured, it publishes a transcoding job to a queue and immediately becomes available for the next live session. This is ideal for your primary recording servers as it keeps them lightweight and responsive."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"transcoderOnly"}),":"]})," This instance will ",(0,r.jsx)(n.em,{children:"only"})," process transcoding jobs. It subscribes to the job queue, performs the CPU-intensive conversion of raw files to MP4, and does not handle any live recordings. You can run a fleet of these workers on cheaper, CPU-optimized VMs to process recordings in parallel without impacting live meetings."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"both"})," (Default):"]})," A single instance performs both live recording and transcoding. This is suitable for smaller setups or if you record infrequently."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Configuration:"})," Each recorder instance must be configured to connect to the same NATS cluster."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Shared Storage:"})," It is ",(0,r.jsx)(n.strong,{children:"critical"})," that all ",(0,r.jsx)(n.code,{children:"recorderOnly"})," and ",(0,r.jsx)(n.code,{children:"transcoderOnly"})," instances have access to the same shared storage location (e.g., NFS, S3) for the recording files."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Action:"})," For detailed setup, refer to the ",(0,r.jsxs)(n.strong,{children:["official ",(0,r.jsx)(n.code,{children:"plugnmeet-recorder"})," repository README"]}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["**(Link: ",(0,r.jsx)(n.a,{href:"https://github.com/mynaparrot/plugNmeet-recorder",children:"Official plugNmeet-recorder README"}),")"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Once your distributed infrastructure is in place, you simply need to update your ",(0,r.jsx)(n.code,{children:"config.yaml"})," file for each ",(0,r.jsx)(n.code,{children:"plugnmeet-server"})," instance to point to the new clustered services."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# Example config snippet\nredis_info:\n  host: "your-redis-cluster-endpoint:6379"\n  # ... other redis settings\n\ndatabase_info:\n  host: "your-mariadb-cluster-endpoint"\n  port: 3306\n  username: "your_user"\n  password: "your_password"\n  db: "plugnmeet"\n\nnats_info:\n  nats_urls:\n    - "nats://node1.your-domain.com:4222"\n    - "nats://node2.your-domain.com:4222"\n    - "nats://node3.your-domain.com:4222"\n\nlivekit_info:\n  host: "http://your-livekit-endpoint" # The endpoint for your LiveKit cluster\n  # ... other livekit settings\n'})}),"\n",(0,r.jsx)(n.p,{children:"By following this conceptual guide and leveraging the official documentation for each component, you can build a robust, scalable plugNmeet deployment capable of supporting a massive user base."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},4482:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(6363);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);